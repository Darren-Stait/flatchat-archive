<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Six Degrees of Football</title>
<link rel="icon" type="image/x-icon" href="icons/flatchat-small.webp">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<link rel="preload" href="../includes/header.html" as="fetch" crossorigin="anonymous">
<link rel="preload" href="../includes/footer.html" as="fetch" crossorigin="anonymous">

<style>
:root {
  --brand: #179aa3;
  --brand-dark: #0f7f86;
  --bg: #f4fbfc;
  --text: #14292f;
  --muted: #546168;
}

* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: 'Inter', sans-serif;
  background: linear-gradient(180deg,var(--bg) 0%, #e6f6f7 100%);
  color: var(--text);
}

.card {
  font-family: 'Inter', sans-serif;
  background: linear-gradient(180deg,#f4fbfc 0%,#e9f7f9 100%);
}

.card {
  position: relative;
  max-width: 1400px;
  margin: 8px auto;
  padding: 20px 24px 24px;
  background: linear-gradient(
    180deg,
    #ffffff 0%,
    #f2fbfc 100%
  );
  border: 2px solid rgba(23,154,163,0.22);
  border-radius: 14px;
  box-shadow:
  0 12px 36px rgba(0,0,0,0.07),
  inset 0 0 40px rgba(23,154,163,0.03);
}

.goal-row {
  background: rgba(23,154,163,0.04);
  padding: 10px;
  border-radius: 12px;
  margin-bottom: 6px;
  display: flex;
  gap: 12px;
  align-items: flex-start;
  justify-content: center;
  flex-wrap: nowrap;
}

.player-card { 
  text-align: center; 
  flex: 0 1 180px;
  min-width: 0;
}

.player-headshot {
  width: clamp(90px, 28vw, 160px);
  height: clamp(90px, 28vw, 160px);
  border-radius: 18px;
  object-fit: cover;
  border: 3px solid var(--brand);
  margin-bottom: 8px;
}

.current-headshot {
  width: clamp(80px, 24vw, 140px);
  height: clamp(80px, 24vw, 140px);
  border-radius: 16px;
  object-fit: cover;
  border: 3px solid var(--brand);
  margin: 6px auto 6px;
  display: block;
}

.target-glow {
  box-shadow: 0 0 0 6px rgba(23,154,163,0.18), 0 6px 18px rgba(23,154,163,0.12);
}

.player-card strong { color: var(--brand); }

.top-centre {
  text-align: center;
  flex: 1 1 180px;
  min-width: 0;
  padding-top: 6px;
}

.top-centre .label {
  font-size: 0.85rem;
  color: var(--muted);
}

.current-name {
  font-size: 1.5rem;
  font-weight: 800;
  color: var(--brand);
  margin-top: 6px;
}

.moves {
  margin-top: 6px;
  font-weight: 600;
  color: var(--brand);
}

.choices-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 12px;
}

.choice-card {
  background: rgba(23,154,163,0.04);
  border-radius: 10px;
  padding: 6px 6px;
  cursor: pointer;
  transition: 0.15s ease;
}

.choice-card img.entity-img {
  width: clamp(50px, 6vw, 70px);
  height: clamp(50px, 6vw, 70px);
}

.choice-card:hover {
  background: rgba(23,154,163,0.12);
  transform: translateY(-3px);
  box-shadow: 0 8px 20px rgba(0,0,0,0.08);
}
/* =============================
   DYNAMIC SHRINK MODES
============================= */

.choices-grid.tight .choice-card {
  padding: 8px 6px;
}

.choices-grid.tight img.entity-img {
  width: 70px;
  height: 70px;
}

.choices-grid.tight .badge-wrapper {
  width: 60px;
  height: 60px;
}

.choices-grid.tight .entity-name {
  font-size: 0.8rem;
}

.choices-grid.tight .entity-years {
  font-size: 0.7rem;
}

.choices-grid.ultra-tight .choice-card {
  padding: 6px 4px;
}

.choices-grid.ultra-tight img.entity-img {
  width: 50px;
  height: 50px;
}

.choices-grid.ultra-tight .badge-wrapper {
  width: 45px;
  height: 45px;
}

.choices-grid.ultra-tight .entity-name {
  font-size: 0.7rem;
}

.choices-grid.ultra-tight .entity-years {
  font-size: 0.65rem;
}

/* =============================
   FULLSCREEN SHRINK LEVELS
============================= */

.card.shrink-1 .choice-card img.entity-img {
  width: 75px;
  height: 75px;
}

.card.shrink-1 .badge-wrapper {
  width: 60px;
  height: 60px;
}

.card.shrink-2 .choice-card img.entity-img {
  width: 60px;
  height: 60px;
}

.card.shrink-2 .badge-wrapper {
  width: 50px;
  height: 50px;
}

.card.shrink-2 .choice-card {
  padding: 6px 4px;
}

.card.shrink-2 .entity-name {
  font-size: 0.75rem;
}

.card.shrink-2 .entity-years {
  font-size: 0.65rem;
}


.club-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  gap: 6px;
  width: 100%;
}

.club-years {
  font-size: 0.85rem;
  font-weight: 600;
  line-height: 1.2;
  min-height: 2.4em;
  max-height: 2.4em;
  overflow: hidden;
}

/* Club badges */
.club-badge {
  max-width: 100%;
  max-height: 100%;
  width: auto;
  height: auto;
  object-fit: contain;
  border: none;
  border-radius: 0;
}

.choice-card:hover img {
  transform: scale(1.05);
}

.choice-card div {
  font-size: 0.85rem;
  font-weight: 600;
  line-height: 1.2;
}

.path {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 8px;
  justify-content: center;
}

.step {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 14px;
  border-radius: 999px;
  background: rgba(37,182,196,0.08);
  border: 1px solid var(--brand);
  font-size: 0.9rem;
}

.step img {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  object-fit: cover;
  border: 2px solid rgba(23,154,163,0.9);
}

button.primary {
  background: var(--brand);
  color: white;
  border: none;
  padding: 12px 18px;
  border-radius: 10px;
  font-weight: 800;
  cursor: pointer;
  box-shadow: 0 6px 14px rgba(23,154,163,0.18);
}

button.primary:hover {
  background: var(--brand-dark);
}

.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10000;
}

.hidden {
  display: none !important;
}

.modal-content {
  background: white;
  padding: 28px;
  border-radius: 12px;
  text-align: center;
  max-width: 420px;
  border: 2px solid rgba(23,154,163,0.18);
}
.separator {
  grid-column: 1 / -1;
  text-align: center;
  margin: 10px 0;
  font-weight: 600;
  color: var(--muted);
  letter-spacing: 1px;
}
.section-header {
  grid-column: 1 / -1;
  text-align: center;
  margin: 15px 0 5px;
  font-weight: 700;
  font-size: 0.9rem;
  color: var(--muted);
  letter-spacing: 1px;
  text-transform: uppercase;
}
#how-to-play {
  background: rgba(23,154,163,0.06);
  padding: 16px 20px;
  border-radius: 12px;
  margin-bottom: 12px;
  border-left: 4px solid var(--brand);
  position: relative;
  transition: all 0.3s ease;
}

#how-to-play.collapsed {
  max-height: 40px;
  overflow: hidden;
}
.howto-toggle {
  position: absolute;
  top: 12px;
  right: 12px;
  background: transparent;
  border: none;
  font-size: 1.4rem;
  cursor: pointer;
  color: var(--brand);
  transition: transform 0.2s ease;
}
.howto-toggle:active {
  transform: scale(0.9);
}
/* FULLSCREEN MODE */
body.fullscreen .card {
  margin: 0;
  max-width: none;
  width: 100vw;
  height: 100vh;
  border-radius: 0;
  box-shadow: none;
  display: flex;
  flex-direction: column;
  /* allow the whole card to scroll internally in fullscreen */
  overflow: auto;
}

body.fullscreen header,
body.fullscreen footer {
  display: none;
}

body.fullscreen {
  overflow: hidden; /* prevent body scroll while allowing card internal scroll */
}

/* =============================
   LOADING OVERLAY
============================= */

#loading-overlay {
  position: fixed;
  inset: 0;
  background: linear-gradient(180deg, var(--bg) 0%, #e6f6f7 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.loading-box {
  text-align: center;
}

.spinner {
  width: 48px;
  height: 48px;
  border: 4px solid rgba(23,154,163,0.2);
  border-top: 4px solid var(--brand);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin: 0 auto 16px;
}

.loading-text {
  font-weight: 600;
  color: var(--brand);
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

#navigation-bar {
  display: flex;
  justify-content: center;
  margin-bottom: 15px;
}
.back-btn {
  background: white;
  border: 2px solid var(--brand);
  color: var(--brand);
  padding: 6px 14px;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.back-btn:hover {
  background: var(--brand);
  color: white;
}

.badge-wrapper {
  width: 70px;
  height: 70px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 auto;
  background: white;
  border-radius: 14px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}

.card {
  position: relative;
  border: 2px solid rgba(23,154,163,0.25);
  background: linear-gradient(180deg,#ffffff 0%,#f7fdfe 100%);
}

.card::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  height: 6px;
  width: 100%;
  background: linear-gradient(
    90deg,
    var(--brand),
    #25b6c4
  );
  border-radius: 14px 14px 0 0;
}

.goal-row {
  background: linear-gradient(
    180deg,
    rgba(23,154,163,0.08),
    rgba(23,154,163,0.03)
  );
  border: 1px solid rgba(23,154,163,0.18);
  box-shadow: inset 0 0 30px rgba(23,154,163,0.03);
}

@media (max-width: 480px) {
  .club-badge {
    max-width: 55px;
    max-height: 55px;
  }
}

.mode-screen {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.mode-box {
  background: white;
  padding: 40px;
  border-radius: 16px;
  border: 2px solid var(--brand);
  text-align: center;
  width: 350px;
}

.mode-btn {
  width: 100%;
  margin: 10px 0;
}

.custom-setup {
  margin-top: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.custom-setup select {
  padding: 8px;
  border: 2px solid var(--brand);
  border-radius: 8px;
}
.menu-btn {
  position: absolute;
  top: 16px;
  left: 16px;
  background: white;
  color: var(--brand);
  border: 2px solid var(--brand);
  border-radius: 10px;
  padding: 6px 12px;
  font-size: 0.85rem;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.08);
  transition: all 0.2s ease;
  z-index: 5;
}

.menu-btn:hover {
  background: var(--brand);
  color: white;
  transform: translateY(-2px);
}
.dead-end-message {
  grid-column: 1 / -1;
  text-align: center;
  padding: 20px;
  font-weight: 600;
  color: var(--brand);
  background: rgba(37,182,196,0.08);
  border-radius: 10px;
}

.large-choice img {
  width: 90px;
  height: 90px;
}

.medium-choice img {
  width: 70px;
  height: 70px;
}

.small-choice img {
  width: 55px;
  height: 55px;
}

.top-bar {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  margin-bottom: 14px;
  width: 100%
}

.top-bar button:nth-child(1) {
  justify-self: start;
}

.top-bar button:nth-child(2) {
  justify-self: center;
  font-weight: 700;
}

.top-bar button:nth-child(3) {
  justify-self: end;
}


#menuTopBtn {
  justify-self: start;
}

#howToBtn {
  justify-self: center;
}

#fullscreenBtn {
  justify-self: end;
}


.top-action-btn {
  background: white;
  border: 2px solid var(--brand);
  color: var(--brand);
  padding: 6px 14px;
  border-radius: 10px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.top-action-btn:hover {
  background: var(--brand);
  color: white;
}

.howto-content {
  position: relative;
}

.modal-close {
  position: absolute;
  top: 12px;
  right: 14px;
  background: transparent;
  border: none;
  font-size: 1.4rem;
  font-weight: 700;
  color: var(--brand);
  cursor: pointer;
  line-height: 1;
  padding: 4px 8px;
  border-radius: 6px;
  transition: 0.2s;
}

.modal-close:hover {
  background: rgba(23,154,163,0.12);
}

.info-tooltip {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--brand);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  position: relative;
  cursor: pointer;
}
.tooltip-text {
  visibility: hidden;
  opacity: 0;
  width: 220px;
  background: white;
  color: #333;
  text-align: left;
  border: 2px solid var(--brand);
  border-radius: 10px;
  padding: 10px;
  position: absolute;
  top: 130%;
  left: 50%;
  transform: translateX(-50%);
  transition: opacity 0.2s ease;
  font-size: 0.85rem;
  z-index: 10;
  box-shadow: 0 6px 18px rgba(0,0,0,0.1);
}

.info-tooltip:hover .tooltip-text {
  visibility: visible;
  opacity: 1;
}

.daily-complete {
  opacity: 0.6;
  filter: grayscale(0.3);
  transition: all 0.3s ease;
}

.daily-complete:hover {
  opacity: 0.6;
  cursor: not-allowed;
}

/* =============================
   DISCORD MODE START SCREEN
============================= */

.discord-mode #min-moves,
.discord-mode #unlimited-mode,
.discord-mode #unlimited-guesses,
.discord-mode #difficulty-select,
.discord-mode #total-players-stat,
.discord-mode #total-pairs-stat,
.discord-mode #randomBtn,
.discord-mode #customBtn {
  display: none !important;
}

.discord-mode .choices-grid {
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
}

/* Hide the unlimited guesses label even if wrapped */
.discord-mode label:has(input[type="checkbox"]) {
  display: none !important;
}

/* Center Daily button */
.discord-mode #start-screen .card {
  display: flex;
  flex-direction: column;
  justify-content: center;
  min-height: 70vh;
  padding-left: 16px;
  padding-right: 16px;
  margin: 0 auto;
}

.discord-mode #dailyBtn {
  font-size: 1.2rem;
  padding: 16px;
}
.daily-timer {
  text-align: center;
  font-size: 0.85rem;
  margin-top: 6px;
  color: var(--brand);
  opacity: 0.8;
}

#howto-toggle-btn {
  display: block;
  margin: 0 auto 20px auto;
}

.discord-mode #howto-toggle-btn {
  align-self: center;
}

/* =============================
   RESPONSIVE LAYOUT
============================= */

#start-screen {
  padding: 40px 20px;
}

#start-screen .card {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
}

#game-container {
  padding-left: 16px;
  padding-right: 16px;
}

/* =============================
   Large Tablets (â‰¤ 1200px)
============================= */
@media (max-width: 1200px) {

  .choices-grid {
    grid-template-columns: repeat(6, 1fr);
  }

}

/* =============================
   Tablets (â‰¤ 900px)
============================= */
@media (max-width: 900px) {

  #start-screen {
    align-items: flex-start;
    min-height: auto;
    padding: 50px 20px;
  }

  #start-screen .card {
    display: flex;
    flex-direction: column;
    gap: 30px;
    padding: 30px 20px;
  }

  .start-left h1 {
    font-size: 2rem;
    text-align: center;
  }

  .start-left p {
    text-align: center;
    font-size: 0.95rem;
  }

  .choices-grid {
    grid-template-columns: repeat(4, 1fr);
  }

}

/* =============================
   Phones (â‰¤ 600px)
============================= */
@media (max-width: 600px) {

  .choices-grid {
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
  }

  .choice-card img.entity-img {
    width: 60px;
    height: 60px;
  }

  .badge-wrapper {
    width: 50px;
    height: 50px;
  }
  .player-headshot {
    width: 90px;
    height: 90px;
  }

  .current-headshot {
    width: 75px;
    height: 75px;
  }
}

/* =============================
   Small Phones (â‰¤ 480px)
============================= */
@media (max-width: 480px) {

  #start-screen {
    padding: 40px 16px;
  }

  .choices-grid {
    grid-template-columns: repeat(2, 1fr);
  }

  .choice-card img.entity-img {
    width: 50px;
    height: 50px;
  }

  .badge-wrapper {
    width: 45px;
    height: 45px;
  }

  .entity-name {
    font-size: 0.75rem;
  }

  .entity-years {
    font-size: 0.65rem;
  }

}

/* =============================
   Fullscreen Mode Adjustment
============================= */
@media (max-width: 768px) {
  body.fullscreen .card {
    height: 100vh;
    overflow-y: auto;
  }

  .player-headshot {
    width: 90px;
    height: 90px;
  }

  .current-headshot {
    width: 75px;
    height: 75px;
  }
}

</style>
</head>

<body>
<div data-include="../includes/header.html"></div>

<div id="loading-overlay">
  <div class="loading-box">
    <div class="spinner"></div>
    <div class="loading-text">Loading game dataâ€¦</div>
  </div>
</div>

<div id="app" style="visibility:hidden;">
<div id="start-screen">
  <div class="card">
<div class="start-left">

  <h1 style="color:var(--brand); margin:0 0 20px 0; font-size:2.8rem; text-align: center;">
    Six Degrees of Football
  </h1>

  <p style="color:var(--muted); text-align: center;">
    Connect footballers through teammates and managers.
    How many moves does it take to link them together?
  </p>
</div>


<div class="start-right">

  <div style="margin-bottom:20px;">
    <select id="min-moves"
            style="
              width:100%;
              padding:12px;
              border-radius:12px;
              border:2px solid var(--brand);
              font-size:1rem;
            ">
      <option value="2">Easy (Minimum 2 Moves)</option>
      <option value="3">Normal (Minimum 3 Moves)</option>
      <option value="4">Hard (Minimum 4 Moves)</option>
      <option value="5">Extreme (Minimum 5 Moves)</option>
    </select>

    <div style="margin-top:15px; display:flex; align-items:center; gap:8px;">
      <input type="checkbox" id="unlimited-mode">
      <label for="unlimited-mode" id="unlimited-txt" style="font-weight:600;">
        Unlimited Guesses
      </label>

      <div class="info-tooltip" id="tooltipID">
        ?
        <span class="tooltip-text">
          If disabled, you lose after 6 moves.
          <br><br>
          Enable to play without a move limit.
        </span>
      </div>
    </div>
  </div>

  <div style="display:flex; flex-direction:column; gap:15px;">
<button id="randomBtn" class="primary">
  Random Game
</button>

<button id="customBtn" class="primary">
  Custom Game
</button>

<button id="dailyBtn" class="primary">
  Daily Challenge
</button>
<div id="daily-reset-timer" class="daily-timer"></div>
  </div>

</div>


  </div>
</div>

<div id="mode-screen" class="hidden">
  <div class="card" style="max-width:500px; margin:50px auto;">

<button id="menuBtn" class="back-btn">
  Back
</button>

    <h2 style="text-align:center; color:var(--brand); margin-top:20px;">
      Custom Game
    </h2>

    <div style="margin-top:30px;">
      <label style="font-weight:600;">Start Player</label>
      <select id="custom-start" style="width:100%; padding:10px; border:2px solid var(--brand); border-radius:10px; margin-bottom:20px;"></select>

      <label style="font-weight:600;">Target Player</label>
      <select id="custom-target" style="width:100%; padding:10px; border:2px solid var(--brand); border-radius:10px;"></select>
    </div>

    <div style="text-align:center; margin-top:30px;">
<button id="startCustomBtn" class="primary">
  Start Custom Game
</button>
    </div>

  </div>
</div>

<div id="game-container" class="hidden">
<div class="card">

<div class="top-bar">
<button id="menuTopBtn" class="top-action-btn">
  Back to Menu
</button>
<button id="howToBtn" class="top-action-btn">
  How To Play
</button>
<button id="fullscreenBtn" class="top-action-btn">
  Fullscreen â›¶
</button>
</div>

  <div class="goal-row">
    <div class="player-card">
      <img id="start-img" class="player-headshot" loading="lazy" decoding="async">
      <div><strong>Start</strong></div>
      <div id="start-name" style="font-weight: 600;"></div>
    </div>

<div class="top-centre">
  <button id="swap-btn" class="top-action-btn">
  â‡„ Swap
  </button>
  <div class="label" id="current-label">Current Player</div>
  <img id="current-img" class="current-headshot" loading="lazy" decoding="async">
  <div class="current-name" id="current-player"></div>
  <div class="moves">Moves: <span id="move-count">0</span></div>
</div>

    <div class="player-card">
      <img id="target-img" class="player-headshot target-glow" loading="lazy" decoding="async">
      <div><strong>Target</strong></div>
      <div id="target-name" style="font-weight: 600;"></div>
    </div>
  </div>

  <div id="navigation-bar" style="margin-top:20px; text-align: center;"></div>
  <div id="choices" class="choices-grid"></div>
  <div id="path" class="path"></div>

  <div style="text-align:center;margin-top:20px;">
    <button id="newPuzzleBtn" class="primary">New Puzzle</button>
  </div>

</div>
</div>

<div id="win-modal" class="modal hidden">
  <div class="modal-content">
    <p id="win-text"></p>
    <button id="winModalBtn" class="primary" style="margin-top:16px;">
      Play Again
    </button>
  </div>
</div>

<div id="daily-modal" class="modal hidden">
  <div class="modal-content">
    <p id="daily-modal-text"></p>
<button id="dailyBackBtn" class="primary">
  Back to Menu
</button>
  </div>
</div>
<div id="howto-modal" class="modal hidden">
  <div class="modal-content howto-content">

    <div class="modal-header">
      <h2>How To Play</h2>
      <button id="howToCloseBtn" class="modal-close">Ã—</button>
    </div>

    <p>
      Your goal is to connect the <strong>start player</strong> to the 
      <strong>target player</strong> through teammates or managers.
      (Tip: you can swap the start and target players if you want to reverse the challenge!)
    </p>

    <h3>Making Moves</h3>
    <ul>
      <li>Select a club. Look through the players and managers they shared time with at that club.</li>
      <li>Then select a player to move onto that player. Your job is to reach the target player.</li>
      <li>Repeat until you reach the target.</li>
    </ul>
    <h3>Note: not every player is in the game, teammates and managers are ovelapped by years at the club so if a player left in the middle of the year and a new manager came in after in the same year they would match at the same club.</h3>
  </div>
</div>
</div>

<div data-include="../includes/footer.html"></div>

<script src="../includes/include-html.js" defer></script>
<script src="./data.js?v=2" defer></script>

<script defer>
let discordSdk = null;

const IS_DISCORD_ACTIVITY =
  window.location.origin.includes("discordsays.com");

let startPlayer, currentEntity, currentType, targetPlayer;
let path = [];
let selectionMode = "club";
let selectedContext = null;
let availablePlayers = [];
let validPairs = [];
let distanceCache = {};
let graphCacheBuilt = false;
let MIN_MOVES = 4;
let UNLIMITED_MODE = true;
const MAX_MOVES = 6;
let CUSTOM_MODE = false;
const reachableCache = {};
let DAILY_MODE = false;
const DEV_UNLOCK = false;

/* =============================
   DAILY STORAGE (Browser + Discord + Dev)
============================= */

/* =============================
   DAILY STORAGE (Browser + Discord Safe)
============================= */

const DailyStorage = (() => {

  const IS_DISCORD =
    window.location.origin.includes("discordsays.com");

  function hasLocalStorage() {
    try {
      return typeof window.localStorage !== "undefined";
    } catch {
      return false;
    }
  }

  async function idbSet(key, value) {
    return new Promise((resolve) => {
      const request = indexedDB.open("sixdegrees-db", 1);

      request.onupgradeneeded = () => {
        request.result.createObjectStore("store");
      };

      request.onsuccess = () => {
        const db = request.result;
        const tx = db.transaction("store", "readwrite");
        tx.objectStore("store").put(value, key);
        tx.oncomplete = () => resolve();
      };
    });
  }

  async function idbGet(key) {
    return new Promise((resolve) => {
      const request = indexedDB.open("sixdegrees-db", 1);

      request.onupgradeneeded = () => {
        request.result.createObjectStore("store");
      };

      request.onsuccess = () => {
        const db = request.result;
        const tx = db.transaction("store", "readonly");
        const getReq = tx.objectStore("store").get(key);

        getReq.onsuccess = () => {
          resolve(getReq.result ?? null);
        };
      };
    });
  }

  async function idbRemove(key) {
    return new Promise((resolve) => {
      const request = indexedDB.open("sixdegrees-db", 1);

      request.onupgradeneeded = () => {
        request.result.createObjectStore("store");
      };

      request.onsuccess = () => {
        const db = request.result;
        const tx = db.transaction("store", "readwrite");
        tx.objectStore("store").delete(key);
        tx.oncomplete = () => resolve();
      };
    });
  }

  return {

    async get(key) {
      if (IS_DISCORD) return await idbGet(key);
      if (hasLocalStorage()) return localStorage.getItem(key);
      return null;
    },

    async set(key, value) {
      if (IS_DISCORD) return await idbSet(key, value);
      if (hasLocalStorage()) localStorage.setItem(key, value);
    },

    async remove(key) {
      if (IS_DISCORD) return await idbRemove(key);
      if (hasLocalStorage()) localStorage.removeItem(key);
    }

  };

})();

window.DailyStorage = DailyStorage;

/* =============================
   UTIL
============================= */
function overlaps(a, b) {
  return Math.max(a[0], b[0]) <= Math.min(a[1], b[1]);
}

function isManager(name) {
  return !!managers[name];
}

function openHowToPlay() {
  document.getElementById("howto-modal").classList.remove("hidden");
}

function closeHowToPlay() {
  document.getElementById("howto-modal").classList.add("hidden");
}

function adaptUIForDiscord() {
  // Hide fullscreen button
  const fullscreenBtn = document.getElementById("fullscreenBtn");
  if (fullscreenBtn) fullscreenBtn.style.display = "none";

  // Optional: auto-launch daily
  showScreen("start-screen");
}

function startDailyCountdown() {

  const timerEl = document.getElementById("daily-reset-timer");
  if (!timerEl) return;

  function update() {

    const { hours, minutes, seconds } = getTimeUntilReset();

    timerEl.textContent =
      `Resets in ${String(hours).padStart(2,"0")}:` +
      `${String(minutes).padStart(2,"0")}:` +
      `${String(seconds).padStart(2,"0")} GMT`;

  }

  update();
  setInterval(update, 1000);
}

function getTimeUntilReset() {

  const now = new Date();

  const nextMidnightUTC = new Date(Date.UTC(
    now.getUTCFullYear(),
    now.getUTCMonth(),
    now.getUTCDate() + 1,
    0, 0, 0
  ));

  const diff = nextMidnightUTC - now;

  const hours = Math.floor(diff / 1000 / 60 / 60);
  const minutes = Math.floor((diff / 1000 / 60) % 60);
  const seconds = Math.floor((diff / 1000) % 60);

  return { hours, minutes, seconds };
}

function beginRandomGame() {

  CUSTOM_MODE = false;
  DAILY_MODE = false;

  MIN_MOVES = parseInt(document.getElementById("min-moves").value, 10);
  UNLIMITED_MODE = document.getElementById("unlimited-mode").checked;

  resetPlayerPool();
  showScreen("game-container");
  startNewGame();
}

function beginCustomGame() {

  MIN_MOVES = parseInt(document.getElementById("min-moves").value, 10);
  UNLIMITED_MODE = document.getElementById("unlimited-mode").checked;

  populateCustomDropdowns();
  showScreen("mode-screen");
}

function openDailyModal(message) {
  const el = document.getElementById("daily-modal-text");
  el.textContent = "";
  el.appendChild(document.createTextNode(message));
  document.getElementById("daily-modal").classList.remove("hidden");
}

function closeDailyModal() {
  document.getElementById("daily-modal").classList.add("hidden");
}

function getTodayKey() {
  const now = new Date();

  const year = now.getUTCFullYear();
  const month = String(now.getUTCMonth() + 1).padStart(2, "0");
  const day = String(now.getUTCDate()).padStart(2, "0");

  return `${year}-${month}-${day}`; // e.g. 2026-02-13
}

function generateDailyPair() {
  return {
    start: "Piero Hincapie",
    target: "Esteban Cambiasso"
  };
}

async function startDailyChallenge() {

  const todayKey = getTodayKey();
  const lastPlayed = await DailyStorage.get("daily-last-played");

  if (!DEV_UNLOCK && lastPlayed === todayKey) {
    openDailyModal(
      "âœ… Youâ€™ve already completed todayâ€™s challenge.\nCome back tomorrow!"
    );
    return;
  }

  DAILY_MODE = true;
  CUSTOM_MODE = false;

  const pair = generateDailyPair();

  // ðŸ”¥ ADD THIS SAFETY CHECK
  if (!players[pair.start] || !players[pair.target]) {
    console.error("Daily pair invalid:", pair);
    DAILY_MODE = false;
    showScreen("start-screen");
    return;
  }

  startPlayer = pair.start;
  targetPlayer = pair.target;

  currentEntity = startPlayer;
  currentType = "player";
  path = [startPlayer];
  selectionMode = "club";
  selectedContext = null;

  UNLIMITED_MODE = true;

  showScreen("game-container");
  render();
}

function swapPlayers() {

  // Only allow swap if no moves made
  if (path.length > 1) {
    return;
  }

  const temp = startPlayer;
  startPlayer = targetPlayer;
  targetPlayer = temp;

  currentEntity = startPlayer;
  currentType = "player";
  path = [startPlayer];
  selectionMode = "club";
  selectedContext = null;

  render();
}

function populateCustomDropdowns() {

  const startSelect = document.getElementById("custom-start");
  const targetSelect = document.getElementById("custom-target");

  startSelect.textContent = "";
  targetSelect.textContent = "";

  const allPlayers = Object.keys(players);

  // In custom mode: allow ANY player as start
  allPlayers.forEach(name => {
    startSelect.add(new Option(name, name));
  });

  startSelect.onchange = function () {

    const selectedStart = this.value;
    targetSelect.textContent = "";

// Single BFS to find all reachable players
const reachable = getReachablePlayers(selectedStart);

reachable.forEach(name => {
  if (name !== selectedStart) {
    targetSelect.add(new Option(name, name));
  }
});

  };

  // Trigger initial target list
  if (allPlayers.length > 0) {
    startSelect.value = allPlayers[0];
    startSelect.onchange();
  }
}

function getReachablePlayers(start) {

  if (reachableCache[start]) {
    return reachableCache[start];
  }

  const visited = new Set([start + "_player"]);
  const queue = [{ name: start, type: "player" }];

  while (queue.length) {

    const current = queue.shift();
    const neighbors = getNeighbors(current);

    for (const n of neighbors) {

      const key = n.name + "_" + n.type;

      if (!visited.has(key)) {
        visited.add(key);
        queue.push(n);
      }
    }
  }

  // Only return players (not managers) for dropdown
  const reachablePlayers = [];

  visited.forEach(key => {
    const [name, type] = key.split("_");
    if (type === "player" && name !== start) {
      reachablePlayers.push(name);
    }
  });

  reachableCache[start] = reachablePlayers;
  return reachablePlayers;
}

function showScreen(screenId) {

  ["start-screen", "mode-screen", "game-container"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add("hidden");
  });

  const target = document.getElementById(screenId);
  if (target) target.classList.remove("hidden");
}

function backToMenu() {
  showScreen("start-screen");
}

function resetPlayerPool(forceRebuild = false) {

  // Always rebuild available players
  availablePlayers = Object.keys(players)
    .filter(p => hasValidConnections(p));

  // Only rebuild full distance cache if forced OR not built yet
  if (forceRebuild || !Object.keys(distanceCache).length) {

    distanceCache = {};

    for (const start of availablePlayers) {
      distanceCache[start] = computeAllShortestPaths(start);
    }
  }
}

function computeAllShortestPaths(startName) {

  const start = { name: startName, type: "player" };
  const queue = [[start, 0]];
  const visited = new Set([startName + "_player"]);

  const result = {};

  while (queue.length) {

    const [node, depth] = queue.shift();
    const key = node.name + "_" + node.type;

    if (node.type === "player" && node.name !== startName) {
      result[node.name] = depth;
    }

    for (const n of getNeighbors(node)) {

      const nKey = n.name + "_" + n.type;

      if (!visited.has(nKey)) {
        visited.add(nKey);
        queue.push([n, depth + 1]);
      }
    }
  }

  return result;
}

/* =============================
   CLUB CONTEXTS (PLAYER OR MANAGER)
============================= */
function getClubContexts(entity) {

  const contexts = [];

  if (currentType === "player") {

    for (const club in players[entity].career) {

      const spells = players[entity].career[club];
      let valid = false;

      spells.forEach(range => {

        const playersList = getPlayersInClubPeriod(club, range)
          .filter(p => p.name !== entity);

        const managersList = getManagersInClubPeriod(club, range);

        if (playersList.length > 0 || managersList.length > 0) {
          valid = true;
        }

      });

      if (valid) contexts.push({ club });
    }

  } else { // manager

    for (const club in managers[entity].career) {

      const spells = managers[entity].career[club];
      let valid = false;

      spells.forEach(range => {

        const playersList = getPlayersInClubPeriod(club, range);

        if (playersList.length > 0) {
          valid = true;
        }

      });

      if (valid) contexts.push({ club });
    }
  }

  return contexts;
}

/* =============================
   PLAYERS IN CLUB PERIOD
============================= */
function getPlayersInClubPeriod(club, range) {
  const res = [];

  for (const p in players) {

    // Skip current entity only if it's a player
    if (currentType === "player" && p === currentEntity) continue;

    if (!players[p].career[club]) continue;

    for (const r of players[p].career[club]) {
      if (overlaps(r, range)) {
        res.push({ name: p, type: "player" });
        break;
      }
    }
  }

  return res;
}

function startRandomMode() {
  document.getElementById("mode-screen").classList.add("hidden");
  startNewGame();
}

function activateCustomMode() {

  document.getElementById("mode-buttons").classList.add("hidden");
  document.getElementById("custom-setup").classList.remove("hidden");

  const startSelect = document.getElementById("custom-start");
  const targetSelect = document.getElementById("custom-target");

  const names = Object.keys(players);

  // Fill start dropdown
  startSelect.textContent = "";
  names.forEach(name => {
    const option = document.createElement("option");
    option.value = name;
    option.textContent = name;
    startSelect.appendChild(option);
  });

  // Initially fill target with valid options
  updateTargetOptions();

  // When start changes â†’ update target
  startSelect.addEventListener("change", updateTargetOptions);
}

async function updateDailyButton() {

  const dailyBtn = document.getElementById("dailyBtn");
  if (!dailyBtn) return;

  const todayKey = getTodayKey();
  const lastPlayed = await DailyStorage.get("daily-last-played");

  if (!DEV_UNLOCK && lastPlayed === todayKey) {
    dailyBtn.disabled = true;
    dailyBtn.textContent = "Daily Challenge âœ“";

    dailyBtn.classList.add("daily-complete");
  } else {
    dailyBtn.disabled = false;
    dailyBtn.textContent = "Daily Challenge";
    dailyBtn.classList.remove("daily-complete");
  }
}

function updateTargetOptions() {

  const start = document.getElementById("custom-start").value;
  const targetSelect = document.getElementById("custom-target");

  targetSelect.textContent = "";

  const names = Object.keys(players);

  names.forEach(name => {

    if (name === start) return;

    const shortest = findShortestPath(start, name);
    const length = shortest ? shortest.length - 1 : Infinity;

    if (length !== Infinity) {

      const option = document.createElement("option");
      option.value = name;
      option.textContent = name;
      targetSelect.appendChild(option);
    }
  });
}

function returnToMenu() {

  DAILY_MODE = false;

  // Exit fullscreen if active
  if (document.fullscreenElement) {
    document.exitFullscreen();
    document.body.classList.remove("fullscreen");
    document.getElementById("fullscreenBtn").textContent = "Fullscreen";
  }

  // Reset mode screen
  document.getElementById("mode-screen").classList.remove("hidden");

  // Reset custom view
  document.getElementById("custom-setup").classList.add("hidden");
  document.getElementById("mode-buttons").classList.remove("hidden");
}

function startCustomMode() {

  CUSTOM_MODE = true;
  const start = document.getElementById("custom-start").value;
  const target = document.getElementById("custom-target").value;

  if (!start || !target) return;

  startPlayer = start;
  targetPlayer = target;

  currentEntity = start;
  currentType = "player";
  path = [start];
  selectionMode = "club";
  selectedContext = null;

  showScreen("game-container");
  render();
}

function getManagersInClubPeriod(club, range) {
  const res = [];

  for (const m in managers) {

    // Prevent manager self-loop
    if (currentType === "manager" && m === currentEntity) continue;

    if (!managers[m].career[club]) continue;

    for (const r of managers[m].career[club]) {
      if (overlaps(r, range)) {
        res.push({ name: m, type: "manager" });
        break;
      }
    }
  }

  return res;
}

function toggleFullscreen() {
  const btn = document.getElementById("fullscreenBtn");

  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
    document.body.classList.add("fullscreen");
    btn.textContent = "Exit Fullscreen";
  } else {
    document.exitFullscreen();
    document.body.classList.remove("fullscreen");
    btn.textContent = "Fullscreen";
  }
}
function renderChoices(items, mode, append = false) {

  const count = items.length;
  let sizeClass = "large-choice";

  if (count > 16) sizeClass = "small-choice";
  else if (count > 8) sizeClass = "medium-choice";


  const container = document.getElementById("choices");

  if (!append && mode === "club") {
    container.textContent = "";
  }

  items.forEach(item => {

    const div = document.createElement("div");
    div.className = `choice-card ${sizeClass}`;

    if (mode === "club") {

      const club = item.club;
      let spells;

      if (currentType === "player") {
        spells = players[currentEntity].career[club];
      } else {
        spells = managers[currentEntity].career[club];
      }

const rangesText = spells
  .map(spell => {
    const s = spell[0];
    const e = spell[1] ?? spell[0];   // â† fix here
    return s === e ? `${s}` : `${s}â€“${e}`;
  })
  .join(", ");

const wrapper = document.createElement("div");
wrapper.className = "club-item";

const badgeWrap = document.createElement("div");
badgeWrap.className = "badge-wrapper";

const img = document.createElement("img");
resolveImage(clubToBadge(club)).then(src => {
  img.src = src;
});
img.className = "club-badge";
img.loading = "lazy";
img.decoding = "async";

badgeWrap.appendChild(img);

const years = document.createElement("div");
years.className = "club-years";
years.textContent = rangesText;

wrapper.appendChild(badgeWrap);
wrapper.appendChild(years);
div.appendChild(wrapper);

      div.addEventListener("click", () => {
        selectedContext = club;
        selectionMode = "entity";
        render();
      });

    } else if (mode === "entity") {

const img = document.createElement("img");
resolveImage(getImage(item.name, item.type)).then(src => {
  img.src = src;
});
img.className = "entity-img";
img.loading = "lazy";
img.decoding = "async";

const textWrap = document.createElement("div");
textWrap.className = "entity-text";

const nameDiv = document.createElement("div");
nameDiv.className = "entity-name";
nameDiv.textContent = item.name;

textWrap.appendChild(nameDiv);

if (item.overlap) {
  const overlapDiv = document.createElement("div");
  overlapDiv.className = "entity-years";
  overlapDiv.textContent = `(${item.overlap})`;
  textWrap.appendChild(overlapDiv);
}

div.appendChild(img);
div.appendChild(textWrap);


div.addEventListener("click", () => {

  currentEntity = item.name;
  currentType = item.type;
  path.push(item.name);

  const movesMade = path.length - 1;

  selectionMode = "club";
  selectedContext = null;

  render();

  if (currentEntity === targetPlayer) {
    checkWin();
    return;
  }

  if (!UNLIMITED_MODE && movesMade >= MAX_MOVES) {
    showLoseModal();
    return;
  }
});


    }

    container.appendChild(div);

  });

  requestAnimationFrame(adjustChoiceGridCompact);
}

const imageBlobCache = {};

async function resolveImage(url) {
  console.log("RESOLVE CALLED:", url);
  return url;
}

function renderNavigation() {
  const nav = document.getElementById("navigation-bar");
  nav.textContent = "";

  if (selectionMode === "entity") {
    const btn = document.createElement("button");
    btn.textContent = "â† Back to Clubs";
    btn.className = "back-btn";
    btn.style.border = "2px solid var(--brand)";
    btn.style.padding = "6px 12px";
    btn.style.fontSize = "0.8rem";

    btn.onclick = () => {
      selectionMode = "club";
      selectedContext = null;
      render();
    };

    nav.appendChild(btn);
  }
}

function toggleHowToPlay() {
  const box = document.getElementById("how-to-play");
  const btn = document.getElementById("howto-toggle-btn");

  box.classList.toggle("collapsed");

  const collapsed = box.classList.contains("collapsed");

  // Save state
  localStorage.setItem("howToPlayCollapsed", collapsed);

  // Update icon
  btn.textContent = collapsed ? "+" : "âˆ’";
}

function addSectionHeader(text) {
  const header = document.createElement("div");
  header.className = "section-header";
  header.textContent = text;
  document.getElementById("choices").appendChild(header);
}

function shortestPathLength(startName, targetName) {

  const result = findShortestPath(startName, targetName);

  if (!result) return Infinity;

  return result.length - 1;
}

/* =============================
   MAIN RENDER
============================= */
function render() {
  renderNavigation();
  document.getElementById("start-name").textContent = startPlayer;
  document.getElementById("target-name").textContent = targetPlayer;
  document.getElementById("current-player").textContent = currentEntity;
  document.getElementById("current-label").textContent =
  currentType === "manager"
    ? "Current Manager"
    : "Current Player";
  resolveImage(getImage(currentEntity, currentType))
    .then(src => document.getElementById("current-img").src = src);
  document.getElementById("move-count").textContent = Math.max(0, path.length - 1);

  resolveImage(getImage(startPlayer))
    .then(src => document.getElementById("start-img").src = src);
  resolveImage(getImage(targetPlayer))
    .then(src => document.getElementById("target-img").src = src);

  const swapBtn = document.getElementById("swap-btn");

  if (swapBtn) {
    swapBtn.style.display = path.length > 1 ? "none" : "inline-block";
  }

const pathContainer = document.getElementById("path");
pathContainer.textContent = "";

path.forEach(p => {

  const step = document.createElement("div");
  step.className = "step";

  const img = document.createElement("img");
  resolveImage(getImage(p)).then(src => {
    img.src = src;
  });
  img.loading = "lazy";
  img.decoding = "async";

  const span = document.createElement("span");
  span.textContent = p;

  step.appendChild(img);
  step.appendChild(span);

  pathContainer.appendChild(step);
});

  if (selectionMode === "club") {
    renderChoices(getClubContexts(currentEntity), "club");
  }

else if (selectionMode === "entity") {

  const club = selectedContext;
  const container = document.getElementById("choices");
  container.textContent = "";

  let playersList = [];
  let managersList = [];

  if (currentType === "player") {

    const playerSpells = players[currentEntity].career[club];

    playerSpells.forEach(pRange => {

      // Players
      for (const p in players) {
        if (p === currentEntity) continue;
        if (!players[p].career[club]) continue;

        players[p].career[club].forEach(oRange => {

          if (overlaps(pRange, oRange)) {

            const overlapStart = Math.max(pRange[0], oRange[0]);
            const overlapEnd = Math.min(pRange[1], oRange[1]);

playersList.push({
  name: p,
  type: "player",
  sortYear: overlapStart,
  overlap: overlapStart === overlapEnd
    ? `${overlapStart}`
    : `${overlapStart}â€“${overlapEnd}`
});
          }
        });
      }

      // Managers
      for (const m in managers) {
        if (!managers[m].career[club]) continue;

        managers[m].career[club].forEach(mRange => {

          if (overlaps(pRange, mRange)) {

            const overlapStart = Math.max(pRange[0], mRange[0]);
            const overlapEnd = Math.min(pRange[1], mRange[1]);

managersList.push({
  name: m,
  type: "manager",
  sortYear: overlapStart,
  overlap: overlapStart === overlapEnd
    ? `${overlapStart}`
    : `${overlapStart}â€“${overlapEnd}`
});
          }
        });
      }

    });

  } else {

    const managerSpells = managers[currentEntity].career[club];

    managerSpells.forEach(mRange => {

      for (const p in players) {

        if (!players[p].career[club]) continue;

        players[p].career[club].forEach(pRange => {

          if (overlaps(mRange, pRange)) {

            const overlapStart = Math.max(mRange[0], pRange[0]);
            const overlapEnd = Math.min(mRange[1], pRange[1]);

playersList.push({
  name: p,
  type: "player",
  sortYear: overlapStart,
  overlap: overlapStart === overlapEnd
    ? `${overlapStart}`
    : `${overlapStart}â€“${overlapEnd}`
});
          }
        });
      }

    });
  }

  // Remove duplicates
  playersList = removeDuplicateEntities(playersList);
  managersList = removeDuplicateEntities(managersList);
  playersList.sort((a, b) => a.sortYear - b.sortYear);
  managersList.sort((a, b) => a.sortYear - b.sortYear);

  if (playersList.length === 0 && managersList.length === 0) {

    const message = document.createElement("div");
    message.className = "dead-end-message";
    message.textContent = "No more players available this way. Try something else.";
    container.appendChild(message);
    return;
  }

  if (playersList.length > 0) {
    addSectionHeader("Players");
    renderChoices(playersList, "entity");
  }

  if (managersList.length > 0 && currentType === "player") {
    addSectionHeader("Managers");
    renderChoices(managersList, "entity", true);
  }
}

}

function removeDuplicateEntities(list) {

  const merged = new Map();

  list.forEach(item => {

    if (!merged.has(item.name)) {
      merged.set(item.name, {
        ...item,
        overlaps: [item.overlap]
      });
    } else {
      merged.get(item.name).overlaps.push(item.overlap);
    }

  });

  return Array.from(merged.values()).map(item => ({
    ...item,
    overlap: item.overlaps.join(", ")
  }));
}

function showRefreshPoolModal() {

const winText = document.getElementById("win-text");
winText.textContent = "";

winText.appendChild(
  document.createTextNode("All available player combinations have been used.")
);

winText.appendChild(document.createElement("br"));
winText.appendChild(document.createElement("br"));

winText.appendChild(
  document.createTextNode("Would you like to refresh the player pool?")
);

  const modal = document.getElementById("win-modal");

  const button = modal.querySelector("button");
  button.textContent = "Refresh Pool";

button.onclick = () => {
  resetPlayerPool(true); // force rebuild
  closeModal();
  startNewGame();
};

  modal.classList.remove("hidden");
}

/* =============================
   GAME START
============================= */
function startNewGame() {

  CUSTOM_MODE = false;
  if (availablePlayers.length < 2) {
    showRefreshPoolModal();
    return;
  }

  let possibleStarts = [];

  for (const s of availablePlayers) {

    const distances = distanceCache[s];
    if (!distances) continue;

    const hasValidTarget = availablePlayers.some(p => {
      if (p === s) return false;
      const d = distances[p];
      return typeof d === "number" && d === MIN_MOVES;
    });

    if (hasValidTarget) {
      possibleStarts.push(s);
    }
  }

  if (possibleStarts.length === 0) {
    showRefreshPoolModal();
    return;
  }

  const s = possibleStarts[Math.floor(Math.random() * possibleStarts.length)];
  const distances = distanceCache[s];

  const possibleTargets = availablePlayers.filter(p => {
    if (p === s) return false;
    const d = distances[p];
    return typeof d === "number" && d === MIN_MOVES;
  });

  if (possibleTargets.length === 0) {
    showRefreshPoolModal();
    return;
  }

  const t = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];

  availablePlayers = availablePlayers.filter(p => p !== s && p !== t);

  startPlayer = s;
  targetPlayer = t;

  currentEntity = s;
  currentType = "player";
  path = [s];
  selectionMode = "club";
  selectedContext = null;

  render();
}

function getImage(name, type = null) {

  let img = null;

  if (type === "player") img = players[name]?.image;
  else if (type === "manager") img = managers[name]?.image;
  else {
    if (players[name]) img = players[name].image;
    if (managers[name]) img = managers[name].image;
  }

  if (!img) return "";

  // If already full URL, leave it
  if (img.startsWith("http://") || img.startsWith("https://")) {
    return img;
  }

  // Otherwise treat as local relative path
  return "./" + img.replace(/^\/+/, "");
}

function clubToBadge(club) {
  const filename = club
    .toLowerCase()
    .replace(/\s+/g, '')
    .replace(/[^a-z0-9]/g, '');

  return `./badges/${filename}.png`;
}

function getNeighbors(entity) {

  const neighbors = [];
  const { name, type } = entity;

  if (type === "player") {

    for (const club in players[name].career) {
      const spells = players[name].career[club];

      for (const spell of spells) {

        // Players
        for (const p in players) {
          if (p === name) continue;
          if (!players[p].career[club]) continue;

          for (const otherSpell of players[p].career[club]) {
            if (overlaps(spell, otherSpell)) {
              neighbors.push({ name: p, type: "player" });
              break;
            }
          }
        }

        // Managers
        for (const m in managers) {
          if (!managers[m].career[club]) continue;

          for (const mSpell of managers[m].career[club]) {
            if (overlaps(spell, mSpell)) {
              neighbors.push({ name: m, type: "manager" });
              break;
            }
          }
        }

      }
    }
  }

  else { // manager

    for (const club in managers[name].career) {
      const spells = managers[name].career[club];

      for (const spell of spells) {

        // Players
        for (const p in players) {
          if (!players[p].career[club]) continue;

          for (const pSpell of players[p].career[club]) {
            if (overlaps(spell, pSpell)) {
              neighbors.push({ name: p, type: "player" });
              break;
            }
          }
        }

        // Managers
        for (const m in managers) {
          if (m === name) continue;
          if (!managers[m].career[club]) continue;

          for (const mSpell of managers[m].career[club]) {
            if (overlaps(spell, mSpell)) {
              neighbors.push({ name: m, type: "manager" });
              break;
            }
          }
        }

      }
    }
  }

  return neighbors;
}

function hasValidConnections(playerName) {

  const start = { name: playerName, type: "player" };
  const neighbors = getNeighbors(start);

  return neighbors.some(n => {
    const second = getNeighbors(n);
    return second.length > 0;
  });
}

function findShortestPath(startName, targetName) {

  const start = { name: startName, type: "player" };
  const targetKey = targetName + "_player";

  const queue = [[start]];
  const visited = new Set([start.name + "_player"]);

  while (queue.length) {

    const path = queue.shift();
    const current = path[path.length - 1];
    const key = current.name + "_" + current.type;

    if (key === targetKey) return path;

    const neighbors = getNeighbors(current);

    for (const neighbor of neighbors) {

      const neighborKey = neighbor.name + "_" + neighbor.type;

      if (!visited.has(neighborKey)) {
        visited.add(neighborKey);
        queue.push([...path, neighbor]);
      }
    }
  }

  return null;
}

async function copyToClipboard(text) {
  try {
    // Modern method
    await navigator.clipboard.writeText(text);
    return true;
  } catch (err) {
    // Fallback for Discord / restricted iframes
    const textarea = document.createElement("textarea");
    textarea.value = text;
    textarea.style.position = "fixed";
    textarea.style.left = "-9999px";
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();

    try {
      document.execCommand("copy");
      document.body.removeChild(textarea);
      return true;
    } catch (err2) {
      document.body.removeChild(textarea);
      return false;
    }
  }
}

async function checkWin() {

  if (currentEntity !== targetPlayer) return;

  const moves = path.length - 1;

  // DAILY MODE
  if (DAILY_MODE) {

    const today = getTodayKey();
    await DailyStorage.set("daily-last-played", getTodayKey());

const moves = path.length - 1;
const pathString = path.join(" â†’ ");

const shareText =
`Six Degrees Daily â€” ${getTodayKey()}
ðŸ§  Completed in ${moves} Moves

My Path:
||${pathString}||`;

openDailyModal("ðŸŽ‰ Daily Challenge Complete!\n\nSolved in " + moves + " moves.\n\n");

const modalText = document.getElementById("daily-modal-text");
if (!modalText) return;

// Create pre block safely
const pre = document.createElement("pre");
pre.id = "shareBlock";
pre.textContent = shareText;

pre.style.background = "#f4fbfc";
pre.style.padding = "12px";
pre.style.borderRadius = "8px";
pre.style.border = "1px solid var(--brand)";
pre.style.whiteSpace = "pre-wrap";
pre.style.fontSize = "0.9rem";
pre.style.textAlign = "left";

// Create button safely
const btn = document.createElement("button");
btn.textContent = "Copy Result";
btn.style.marginTop = "10px";
btn.style.padding = "8px 14px";
btn.style.background = "var(--brand)";
btn.style.color = "white";
btn.style.border = "none";
btn.style.borderRadius = "6px";
btn.style.cursor = "pointer";

btn.addEventListener("click", async () => {

  const success = await copyToClipboard(shareText);

  if (success) {
    btn.textContent = "Copied!";
  } else {
    btn.textContent = "Press Ctrl+C";
  }

  setTimeout(() => btn.textContent = "Copy Result", 1500);

});

modalText.appendChild(pre);
modalText.appendChild(btn);


setTimeout(() => {

  const btn = document.getElementById("copyShareBtn");
  if (!btn) return;

btn.addEventListener("click", async () => {

  const formatted =
`\`\`\`
${shareText}
\`\`\``;

  const success = await copyToClipboard(formatted);

  if (success) {
    btn.textContent = "Copied!";
  } else {
    btn.textContent = "Press Ctrl+C";
  }

  setTimeout(() => btn.textContent = "Copy Result", 1500);

});

}, 0);


    DAILY_MODE = false;
    updateDailyButton();
    showScreen("start-screen");
    return;
  }

  // CUSTOM MODE (no shortest path)
  if (CUSTOM_MODE) {

    const winText = document.getElementById("win-text");
    winText.textContent = `ðŸŽ‰ You connected them in ${moves} moves.`;

    document.getElementById("win-modal")
      .classList.remove("hidden");
    return;
  }

  // RANDOM MODE (show shortest path)
  const shortest = findShortestPath(startPlayer, targetPlayer);
  const optimalText = shortest
  .map(step => typeof step === "string" ? step : step.name)
  .join(" â†’ ");

  const winText = document.getElementById("win-text");
  winText.textContent = "";

  winText.appendChild(
    document.createTextNode(
      `ðŸŽ‰ You connected them in ${moves} moves.`
    )
  );

  winText.appendChild(document.createElement("br"));
  winText.appendChild(document.createElement("br"));

  const strong = document.createElement("strong");
  strong.textContent = "Shortest possible path:";
  winText.appendChild(strong);

  winText.appendChild(document.createElement("br"));

  winText.appendChild(
    document.createTextNode(optimalText)
  );

  document.getElementById("win-modal")
    .classList.remove("hidden");
}

function generateDailyShareText() {

  const moves = path.length - 1;

  return `Six Degrees
${startPlayer} â†’ ${targetPlayer}
Solved in ${moves} moves`;
}

function copyDailyResult() {

  const text = generateDailyShareText();

copyToClipboard(text).then(success => {
  if (success) {
    alert("Result copied to clipboard!");
  } else {
    alert("Press Ctrl+C to copy.");
  }
});

}

async function shareDailyResult() {

  const text = generateDailyShareText();

  if (navigator.share) {
    try {
      await navigator.share({
        text: text
      });
    } catch (err) {
      console.log("Share cancelled");
    }
  } else {
    copyDailyResult();
  }
}

function showLoseModal() {

  const shortest = findShortestPath(startPlayer, targetPlayer);

  let optimalText = "";

  if (shortest) {
    optimalText = shortest.map(n => n.name).join(" â†’ ");
  }

const winText = document.getElementById("win-text");
winText.textContent = "";

winText.appendChild(
  document.createTextNode("âŒ You ran out of moves.")
);

winText.appendChild(document.createElement("br"));
winText.appendChild(document.createElement("br"));

const strong = document.createElement("strong");
strong.textContent = "Shortest possible path:";
winText.appendChild(strong);

winText.appendChild(document.createElement("br"));

winText.appendChild(
  document.createTextNode(optimalText)
);

  const modal = document.getElementById("win-modal");

  const button = document.getElementById("winModalBtn");
  button.textContent = "Try Again";

  modal.classList.remove("hidden");
}

function closeModal() {
  document.getElementById("win-modal").classList.add("hidden");
}

window.addEventListener("load", () => {
  const collapsed = localStorage.getItem("howToPlayCollapsed") === "true";
  const box = document.getElementById("how-to-play");
  const btn = document.getElementById("howto-toggle-btn");

  if (collapsed) {
    box.classList.add("collapsed");
    btn.textContent = "+";
  } else {
    btn.textContent = "âˆ’";
  }
});

document.addEventListener("fullscreenchange", () => {
  const btn = document.getElementById("fullscreenBtn");

  if (!document.fullscreenElement) {
    document.body.classList.remove("fullscreen");
    btn.textContent = "Fullscreen";
  }
});

function initialiseGame() {

  if (typeof players === "undefined") {
    console.error("Players not loaded.");
    return;
  }

  resetPlayerPool(true);
  updateDailyButton();

  document.getElementById("loading-overlay")?.remove();
  document.getElementById("app").style.visibility = "visible";
}


function adjustChoiceGridCompact() {

  const card = document.querySelector('#game-container .card');
  if (!card) return;

  card.classList.remove('shrink-1', 'shrink-2');

  const viewportHeight = window.innerHeight;

  // First check: does it overflow?
  if (card.scrollHeight <= viewportHeight) return;

  // Apply shrink level 1
  card.classList.add('shrink-1');

  requestAnimationFrame(() => {

    if (card.scrollHeight <= window.innerHeight) return;

    // Still overflowing â†’ apply shrink level 2
    card.classList.remove('shrink-1');
    card.classList.add('shrink-2');

  });
}

function enforceDiscordMode() {

  if (!IS_DISCORD_ACTIVITY) return;

  // Add body flag (optional but clean)
  document.body.classList.add("discord-mode");

  // Hide everything except Daily + How To Play
  const elementsToHide = [
    "randomBtn",
    "customBtn",
    "fullscreenBtn",
    "menuBtn",
    "menuTopBtn",
    "swap-btn",
    "startCustomBtn",
    "newPuzzleBtn",
    "tooltipID",
    "unlimited-txt"
  ];

  elementsToHide.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });

  // Hide custom screen entirely
  const customScreen = document.getElementById("custom-screen");
  if (customScreen) customScreen.remove();

  // Auto-start daily challenge
  startDailyChallenge();
}

function attachEventListeners() {

  document.getElementById("randomBtn")
    ?.addEventListener("click", beginRandomGame);

  document.getElementById("customBtn")
    ?.addEventListener("click", beginCustomGame);

  document.getElementById("dailyBtn")
    ?.addEventListener("click", startDailyChallenge);

  document.getElementById("menuBtn")
    ?.addEventListener("click", () => showScreen("start-screen"));

  document.getElementById("menuTopBtn")
    ?.addEventListener("click", () => showScreen("start-screen"));

  document.getElementById("howToBtn")
    ?.addEventListener("click", openHowToPlay);

  document.getElementById("howToCloseBtn")
    ?.addEventListener("click", closeHowToPlay);

  document.getElementById("fullscreenBtn")
    ?.addEventListener("click", toggleFullscreen);

  document.getElementById("swap-btn")
    ?.addEventListener("click", swapPlayers);

  document.getElementById("startCustomBtn")
    ?.addEventListener("click", startCustomMode);

  document.getElementById("newPuzzleBtn")
    ?.addEventListener("click", startNewGame);

  document.getElementById("dailyBackBtn")
    ?.addEventListener("click", closeDailyModal);
  document.getElementById("winModalBtn")
  ?.addEventListener("click", () => {
    closeModal();
    startNewGame();
  });
}

window.addEventListener('resize', () => {
  adjustChoiceGridCompact();
});

window.addEventListener("DOMContentLoaded", async () => {

  try {
    resetPlayerPool(true);
    attachEventListeners();
    setTimeout(async () => {
      await updateDailyButton();
    }, 50);
    startDailyCountdown();
    if (IS_DISCORD_ACTIVITY) {
      enforceDiscordMode();
    }
  } catch (err) {
    console.error("Initialisation error:", err);
  }

  const app = document.getElementById("app");
  const overlay = document.getElementById("loading-overlay");

  if (app) app.style.visibility = "visible";
  if (overlay) overlay.style.display = "none";

});

window.devTools = {

  async resetDaily() {
    const key = "daily-played-" + getTodayKey();
    await DailyStorage.remove(key);
    console.log("Daily reset");
  },

  enableDevOverride() {
    history.replaceState(null, "", "?dev=1");
    location.reload();
  },

  disableDevOverride() {
    history.replaceState(null, "", window.location.pathname);
    location.reload();
  }

};

</script>
</body>
</html>
