<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Six Degrees of Seperation - Football</title>
  <link rel="icon" type="image/x-icon" href="icons/flatchat-small.webp">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<link rel="preload" href="../includes/header.html" as="fetch" crossorigin="anonymous">
<link rel="preload" href="../includes/footer.html" as="fetch" crossorigin="anonymous">

<style>
:root {
  --brand: #179aa3;
  --brand-dark: #0f7f86;
  --bg: #f4fbfc;
  --text: #14292f;
  --muted: #546168;
}

* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: 'Inter', sans-serif;
  background: linear-gradient(180deg,var(--bg) 0%, #e6f6f7 100%);
  color: var(--text);
}

.card {
  font-family: 'Inter', sans-serif;
  background: linear-gradient(180deg,#f4fbfc 0%,#e9f7f9 100%);
}

.card {
  position: relative;
  max-width: 1400px;
  margin: 8px auto;
  padding: 20px 24px 24px;
  background: linear-gradient(
    180deg,
    #ffffff 0%,
    #f2fbfc 100%
  );
  border: 2px solid rgba(23,154,163,0.22);
  border-radius: 14px;
  box-shadow:
  0 12px 36px rgba(0,0,0,0.07),
  inset 0 0 40px rgba(23,154,163,0.03);
}

.goal-row {
  background: rgba(23,154,163,0.04);
  padding: 12px;
  border-radius: 12px;
  margin-bottom: 6px;
  display: flex;
  gap: 18px;
  align-items: center;
  justify-content: space-between;
}

.player-card { text-align: center; }

.player-headshot {
  width: 160px;
  height: 160px;
  border-radius: 18px;
  object-fit: cover;
  border: 3px solid var(--brand);
  margin-bottom: 8px;
}

.current-headshot {
  width: 140px;
  height: 140px;
  border-radius: 16px;
  object-fit: cover;
  border: 3px solid var(--brand);
  margin: 6px auto 6px;
  display: block;
}

.target-glow {
  box-shadow: 0 0 0 6px rgba(23,154,163,0.18), 0 6px 18px rgba(23,154,163,0.12);
}

.player-card strong { color: var(--brand); }

.top-centre {
  text-align: center;
  min-width: 220px;
}

.top-centre .label {
  font-size: 0.85rem;
  color: var(--muted);
}

.current-name {
  font-size: 1.5rem;
  font-weight: 800;
  color: var(--brand);
  margin-top: 6px;
}

.moves {
  margin-top: 6px;
  font-weight: 600;
  color: var(--brand);
}

.choices-grid {
  display: grid;
  gap: 10px;
  grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
}

.choice-card {
  background: rgba(23,154,163,0.04);
  border-radius: 10px;
  padding: 6px 6px;
  cursor: pointer;
  transition: 0.15s ease;
}

.choice-card img.entity-img {
  width: 85px;
  height: 85px;
  object-fit: cover;
  border-radius: 12px;
  border: 2px solid rgba(23,154,163,0.9);
}

.choice-card:hover {
  background: rgba(23,154,163,0.12);
  transform: translateY(-3px);
  box-shadow: 0 8px 20px rgba(0,0,0,0.08);
}
/* =============================
   DYNAMIC SHRINK MODES
============================= */

.choices-grid.tight .choice-card {
  padding: 8px 6px;
}

.choices-grid.tight img.entity-img {
  width: 70px;
  height: 70px;
}

.choices-grid.tight .badge-wrapper {
  width: 60px;
  height: 60px;
}

.choices-grid.tight .entity-name {
  font-size: 0.8rem;
}

.choices-grid.tight .entity-years {
  font-size: 0.7rem;
}

.choices-grid.ultra-tight .choice-card {
  padding: 6px 4px;
}

.choices-grid.ultra-tight img.entity-img {
  width: 50px;
  height: 50px;
}

.choices-grid.ultra-tight .badge-wrapper {
  width: 45px;
  height: 45px;
}

.choices-grid.ultra-tight .entity-name {
  font-size: 0.7rem;
}

.choices-grid.ultra-tight .entity-years {
  font-size: 0.65rem;
}

/* =============================
   FULLSCREEN SHRINK LEVELS
============================= */

.card.shrink-1 .choice-card img.entity-img {
  width: 75px;
  height: 75px;
}

.card.shrink-1 .badge-wrapper {
  width: 60px;
  height: 60px;
}

.card.shrink-2 .choice-card img.entity-img {
  width: 60px;
  height: 60px;
}

.card.shrink-2 .badge-wrapper {
  width: 50px;
  height: 50px;
}

.card.shrink-2 .choice-card {
  padding: 6px 4px;
}

.card.shrink-2 .entity-name {
  font-size: 0.75rem;
}

.card.shrink-2 .entity-years {
  font-size: 0.65rem;
}


.club-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  gap: 6px;
  width: 100%;
}

.club-years {
  font-size: 0.85rem;
  font-weight: 600;
  line-height: 1.2;
  min-height: 2.4em;
  max-height: 2.4em;
  overflow: hidden;
}

/* Club badges */
.club-badge {
  max-width: 100%;
  max-height: 100%;
  width: auto;
  height: auto;
  object-fit: contain;
  border: none;
  border-radius: 0;
}

.choice-card:hover img {
  transform: scale(1.05);
}

.choice-card div {
  font-size: 0.85rem;
  font-weight: 600;
  line-height: 1.2;
}

.path {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 8px;
  justify-content: center;
}

.step {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 14px;
  border-radius: 999px;
  background: rgba(37,182,196,0.08);
  border: 1px solid var(--brand);
  font-size: 0.9rem;
}

.step img {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  object-fit: cover;
  border: 2px solid rgba(23,154,163,0.9);
}

button.primary {
  background: var(--brand);
  color: white;
  border: none;
  padding: 12px 18px;
  border-radius: 10px;
  font-weight: 800;
  cursor: pointer;
  box-shadow: 0 6px 14px rgba(23,154,163,0.18);
}

button.primary:hover {
  background: var(--brand-dark);
}

.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  display: flex;
  justify-content: center;
  align-items: center;
}

.hidden {
  display: none !important;
}

.modal-content {
  background: white;
  padding: 28px;
  border-radius: 12px;
  text-align: center;
  max-width: 420px;
  border: 2px solid rgba(23,154,163,0.18);
}
.separator {
  grid-column: 1 / -1;
  text-align: center;
  margin: 10px 0;
  font-weight: 600;
  color: var(--muted);
  letter-spacing: 1px;
}
.section-header {
  grid-column: 1 / -1;
  text-align: center;
  margin: 15px 0 5px;
  font-weight: 700;
  font-size: 0.9rem;
  color: var(--muted);
  letter-spacing: 1px;
  text-transform: uppercase;
}
#how-to-play {
  background: rgba(23,154,163,0.06);
  padding: 16px 20px;
  border-radius: 12px;
  margin-bottom: 12px;
  border-left: 4px solid var(--brand);
  position: relative;
  transition: all 0.3s ease;
}

#how-to-play.collapsed {
  max-height: 40px;
  overflow: hidden;
}
.howto-toggle {
  position: absolute;
  top: 12px;
  right: 12px;
  background: transparent;
  border: none;
  font-size: 1.4rem;
  cursor: pointer;
  color: var(--brand);
  transition: transform 0.2s ease;
}
.howto-toggle:active {
  transform: scale(0.9);
}
/* FULLSCREEN MODE */
body.fullscreen .card {
  margin: 0;
  max-width: none;
  width: 100vw;
  height: 100vh;
  border-radius: 0;
  box-shadow: none;
  display: flex;
  flex-direction: column;
  /* allow the whole card to scroll internally in fullscreen */
  overflow: auto;
}

body.fullscreen header,
body.fullscreen footer {
  display: none;
}

body.fullscreen {
  overflow: hidden; /* prevent body scroll while allowing card internal scroll */
}

/* =============================
   LOADING OVERLAY
============================= */

#loading-overlay {
  position: fixed;
  inset: 0;
  background: linear-gradient(180deg, var(--bg) 0%, #e6f6f7 100%);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.loading-box {
  text-align: center;
}

.spinner {
  width: 48px;
  height: 48px;
  border: 4px solid rgba(23,154,163,0.2);
  border-top: 4px solid var(--brand);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin: 0 auto 16px;
}

.loading-text {
  font-weight: 600;
  color: var(--brand);
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

#navigation-bar {
  display: flex;
  justify-content: center;
  margin-bottom: 15px;
}
.back-btn {
  background: white;
  border: 2px solid var(--brand);
  color: var(--brand);
  padding: 6px 14px;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.back-btn:hover {
  background: var(--brand);
  color: white;
}

.badge-wrapper {
  width: 70px;
  height: 70px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 auto;
  background: white;
  border-radius: 14px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}

.card {
  background: #fbffff;
}


@media (max-width: 480px) {
  .club-badge {
    max-width: 55px;
    max-height: 55px;
  }
}

.mode-screen {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.mode-box {
  background: white;
  padding: 40px;
  border-radius: 16px;
  border: 2px solid var(--brand);
  text-align: center;
  width: 350px;
}

.mode-btn {
  width: 100%;
  margin: 10px 0;
}

.custom-setup {
  margin-top: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.custom-setup select {
  padding: 8px;
  border: 2px solid var(--brand);
  border-radius: 8px;
}
.menu-btn {
  position: absolute;
  top: 16px;
  left: 16px;
  background: white;
  color: var(--brand);
  border: 2px solid var(--brand);
  border-radius: 10px;
  padding: 6px 12px;
  font-size: 0.85rem;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.08);
  transition: all 0.2s ease;
  z-index: 5;
}

.menu-btn:hover {
  background: var(--brand);
  color: white;
  transform: translateY(-2px);
}
.dead-end-message {
  grid-column: 1 / -1;
  text-align: center;
  padding: 20px;
  font-weight: 600;
  color: var(--brand);
  background: rgba(37,182,196,0.08);
  border-radius: 10px;
}

.large-choice img {
  width: 90px;
  height: 90px;
}

.medium-choice img {
  width: 70px;
  height: 70px;
}

.small-choice img {
  width: 55px;
  height: 55px;
}

.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.top-action-btn {
  background: white;
  border: 2px solid var(--brand);
  color: var(--brand);
  padding: 6px 14px;
  border-radius: 10px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.top-action-btn:hover {
  background: var(--brand);
  color: white;
}

.info-tooltip {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--brand);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  position: relative;
  cursor: pointer;
}
.tooltip-text {
  visibility: hidden;
  opacity: 0;
  width: 220px;
  background: white;
  color: #333;
  text-align: left;
  border: 2px solid var(--brand);
  border-radius: 10px;
  padding: 10px;
  position: absolute;
  top: 130%;
  left: 50%;
  transform: translateX(-50%);
  transition: opacity 0.2s ease;
  font-size: 0.85rem;
  z-index: 10;
  box-shadow: 0 6px 18px rgba(0,0,0,0.1);
}

.info-tooltip:hover .tooltip-text {
  visibility: visible;
  opacity: 1;
}

@media (max-width: 768px) {

  .club-badge {
    max-width: 70px;
    max-height: 70px;
  }

  /* Make the whole top area compact */
  .goal-row {
    flex-direction: row !important;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    margin-bottom: 10px;
  }

  .goal-row img {
    margin-bottom: 2px;
  }

  .top-centre {
    margin-bottom: 4px;
  }

  /* Remove vertical stacking */
  .goal-row > div {
    flex: 1;
    text-align: center;
  }

  /* Shrink all headshots */
  .player-headshot,
  .current-headshot {
    width: 48px !important;
    height: 48px !important;
    border-radius: 10px;
  }

  /* Reduce name size */
  .player-name,
  .current-name {
    font-size: 0.7rem;
    line-height: 1.1;
  }

  /* Hide big labels */
  .label {
    display: none;
  }

  /* Reduce moves size */
  .moves {
    font-size: 0.75rem;
  }

  /* Reduce card padding */
  .card {
    margin: 10px;
    padding: 45px 12px 15px;
  }

  .club-badge {
    max-width: 70px;
    max-height: 70px;
  }
.entity-text {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.entity-name {
  font-weight: 600;
  font-size: 0.85rem;
  line-height: 1.2;
}

.entity-years {
  font-size: 0.75rem;
  color: var(--muted);
  line-height: 1.2;
}

#start-screen {
  min-height: 100vh;
  display: flex;
  align-items: stretch;
  justify-content: center;
  padding: 40px 5vw;
}

#start-screen .card {
  width: 100%;
  max-width: 1200px;
  display: grid;
  grid-template-columns: 1.2fr 1fr;
  gap: 60px;
  align-items: center;
  padding: 60px 60px;
}

.start-left h1 {
  font-size: 3.2rem;
  font-weight: 800;
  line-height: 1.1;
  margin-bottom: 20px;
}

.start-left p {
  font-size: 1.05rem;
  color: var(--muted);
  max-width: 480px;
}

.start-right {
  max-width: 420px;
  margin-left: auto;
}

/* Shared game-style card */
.game-card {
  background: white;
  border: 2px solid var(--brand);
  border-radius: 20px;
  padding: 50px 60px;
  box-shadow: 0 20px 50px rgba(0,0,0,0.08);
  width: 380px;
  text-align: center;
}

#game-container .card {
  display: flex;
  flex-direction: column;
  /* limit card height so inner areas can scroll instead of overflowing */
  max-height: calc(100vh - 24px);
  overflow: hidden;
  padding: 16px 20px 20px;
}

#game-container .card::before {
  content: "";
  display: block;
  height: 6px;
  width: 100%;
  background: linear-gradient(
    90deg,
    var(--brand),
    #25b6c4
  );
  border-radius: 14px 14px 0 0;
  position: absolute;
  top: 0;
  left: 0;
}

#choices {
  flex: 1;
  align-content: start;
  /* allow the choices region to scroll when content grows */
  overflow: auto;
  min-height: 0; /* necessary for flex children to shrink properly */
  padding-right: 8px; /* room for scrollbar */
  background: rgba(23,154,163,0.03);
  padding: 12px;
  border-radius: 12px;
}

.game-title {
  font-size: 2.4rem;
  font-weight: 700;
  color: var(--brand);
  margin-bottom: 15px;
}

.start-stat {
  font-size: 0.9rem;
  color: var(--muted);
  margin-bottom: 30px;
}

.start-control {
  margin-bottom: 30px;
  text-align: left;
}

.start-control label {
  display: block;
  font-weight: 600;
  margin-bottom: 8px;
}

/* Styled dropdown */
.select-wrapper {
  position: relative;
}

.select-wrapper select {
  width: 100%;
  padding: 10px 12px;
  font-size: 1rem;
  border: 2px solid var(--brand);
  border-radius: 10px;
  background: white;
  appearance: none;
  cursor: pointer;
  transition: 0.2s ease;
}

.select-wrapper select:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(37,182,196,0.2);
}

.start-buttons {
  display: flex;
  flex-direction: column;
  gap: 14px;
}

.primary-btn {
  padding: 12px;
  font-size: 1rem;
  font-weight: 600;
  background: var(--brand);
  color: white;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  transition: 0.2s ease;
}

.primary-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 20px rgba(0,0,0,0.15);
}

.secondary-btn {
  padding: 12px;
  font-size: 1rem;
  font-weight: 600;
  background: white;
  color: var(--brand);
  border: 2px solid var(--brand);
  border-radius: 12px;
  cursor: pointer;
  transition: 0.2s ease;
}

.secondary-btn:hover {
  background: var(--brand);
  color: white;
}
.menu-card {
  background: #f3f7f8;
  border-radius: 12px;
  padding: 36px 40px;
  text-align: center;
  max-width: 760px;
  margin: 18px auto;
}

.menu-title {
  font-size: 2.5rem;
  color: var(--brand);
  margin-bottom: 10px;
}

.menu-stat {
  font-size: 0.9rem;
  color: #666;
  margin-bottom: 30px;
}

.menu-section {
  margin-bottom: 35px;
  text-align: left;
}

.menu-section label {
  font-weight: 600;
  display: block;
  margin-bottom: 10px;
}

.styled-select {
  width: 100%;
  padding: 12px 14px;
  border-radius: 12px;
  border: 2px solid var(--brand);
  font-size: 1rem;
  background: white;
  cursor: pointer;
  transition: 0.2s ease;
}

.styled-select:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(37,182,196,0.25);
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.primary-btn {
  padding: 14px;
  border-radius: 12px;
  border: none;
  background: var(--brand);
  color: white;
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: 0.2s ease;
}

.primary-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(0,0,0,0.15);
}

.outline-btn {
  padding: 14px;
  border-radius: 12px;
  border: 2px solid var(--brand);
  background: white;
  color: var(--brand);
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: 0.2s ease;
}

.outline-btn:hover {
  background: var(--brand);
  color: white;
}

}

@media (max-width: 480px) {

  .large-choice img { width: 70px; height: 70px; }
  .medium-choice img { width: 55px; height: 55px; }
  .small-choice img { width: 45px; height: 45px; }

  .current-name {
    font-size: 1rem;
  }
}

@media (max-width: 1200px) {
  .choices-grid {
    grid-template-columns: repeat(8, 1fr);
  }
}

@media (max-width: 900px) {
  .choices-grid {
    grid-template-columns: repeat(6, 1fr);
  }
  #start-screen .card {
    grid-template-columns: 1fr;
    gap: 40px;
    padding: 40px 20px;
  }

  .start-right {
    margin-left: 0;
    max-width: 100%;
  }

  .start-left h1 {
    font-size: 2.4rem;
  }
}

@media (max-width: 600px) {
  .choices-grid {
    grid-template-columns: repeat(auto-fit, minmax(85px, 1fr));
  }

  .choice-card img.entity-img {
    width: 60px;
    height: 60px;
  }

  .badge-wrapper {
    width: 50px;
    height: 50px;
  }
}

@media (max-width: 420px) {
  .choices-grid {
    grid-template-columns: repeat(3, 1fr);
  }

  .choice-card img {
    width: 45px;
    height: 45px;
  }
}
</style>
</head>

<body>
<div data-include="../includes/header.html"></div>

<div id="loading-overlay">
  <div class="loading-box">
    <div class="spinner"></div>
    <div class="loading-text">Loading game data‚Ä¶</div>
  </div>
</div>

<div id="app" style="visibility:hidden;">
<div id="start-screen">
  <div class="card">
<div class="start-left">

  <h1 style="color:var(--brand); margin:0 0 20px 0; font-size:2.8rem; text-align: center;">
    Six Degrees of Seperation
  </h1>

  <p style="color:var(--muted); text-align: center;">
    Connect footballers through teammates and managers.
    How many moves does it take to link them together?
  </p>

  <div class="menu-stat" style="margin-top:30px;">
    <div id="total-players-stat"></div>
    <div id="total-pairs-stat" style="margin-top:6px;"></div>
  </div>

</div>


<div class="start-right">

  <div style="margin-bottom:20px;">
    <select id="min-moves"
            style="
              width:100%;
              padding:12px;
              border-radius:12px;
              border:2px solid var(--brand);
              font-size:1rem;
            ">
      <option value="2" selected>Easy (Minimum 2 Moves)</option>
      <option value="3">Normal (Minimum 3 Moves)</option>
      <option value="4">Hard (Minimum 4 Moves)</option>
      <option value="5">Extreme (Minimum 5 Moves)</option>
      <option value="6">Insane (Minimum 6 Moves)</option>
    </select>

    <div style="margin-top:15px; display:flex; align-items:center; gap:8px;">
      <input type="checkbox" id="unlimited-mode">
      <label for="unlimited-mode" style="font-weight:600;">
        Unlimited Guesses
      </label>

      <div class="info-tooltip">
        ?
        <span class="tooltip-text">
          If disabled, you lose after 6 moves.
          <br><br>
          Enable to play without a move limit.
        </span>
      </div>
    </div>
  </div>

  <div style="display:flex; flex-direction:column; gap:15px;">
    <button class="primary" onclick="beginRandomGame()">
      Random Game
    </button>

    <button class="back-btn" onclick="beginCustomGame()">
      Custom Game
    </button>
  </div>

</div>


  </div>
</div>

<div id="mode-screen" class="hidden">
  <div class="card" style="max-width:500px; margin:50px auto;">

    <button class="back-btn" onclick="showScreen('start-screen')">
      Back
    </button>

    <h2 style="text-align:center; color:var(--brand); margin-top:20px;">
      Custom Game
    </h2>

    <div style="margin-top:30px;">
      <label style="font-weight:600;">Start Player</label>
      <select id="custom-start" style="width:100%; padding:10px; border:2px solid var(--brand); border-radius:10px; margin-bottom:20px;"></select>

      <label style="font-weight:600;">Target Player</label>
      <select id="custom-target" style="width:100%; padding:10px; border:2px solid var(--brand); border-radius:10px;"></select>
    </div>

    <div style="text-align:center; margin-top:30px;">
      <button class="primary" onclick="startCustomMode()">
        Start Custom Game
      </button>
    </div>

  </div>
</div>

<div id="game-container" class="hidden">
<div class="card">

<div class="top-bar">
  <button class="top-action-btn" onclick="showScreen('start-screen')">
    Back to Menu
  </button>

<button id="fullscreenBtn" class="top-action-btn" onclick="toggleFullscreen()">
  Fullscreen ‚õ∂
</button>
</div>

  <div id="how-to-play">
    <button id="howto-toggle-btn" onclick="toggleHowToPlay()" class="howto-toggle">‚àí</button>
    <h3 style="margin-top:0;color:var(--brand);">How to Play</h3>
    <p style="margin:8px 0;font-size:0.95rem;">Connect the <strong>Start</strong> player to the <strong>Target</strong> player by finding teammates or managers who they once shared a club with. Select a club from the start player's career, then pick a teammate or manager they worked with/under. Keep moving through teammates/managers until you reach the target player!</p>
  </div>

  <div class="goal-row">
    <div class="player-card">
      <img id="start-img" class="player-headshot" loading="lazy" decoding="async">
      <div><strong>Start</strong></div>
      <div id="start-name" style="font-weight: 600;"></div>
    </div>

<div class="top-centre">
  <button id="swap-btn" class="top-action-btn" onclick="swapPlayers()">
  ‚áÑ Swap Start and Target Players
  </button>
  <div class="label" id="current-label">Current Player</div>
  <img id="current-img" class="current-headshot" loading="lazy" decoding="async">
  <div class="current-name" id="current-player"></div>
  <div class="moves">Moves: <span id="move-count">0</span></div>
</div>

    <div class="player-card">
      <img id="target-img" class="player-headshot target-glow" loading="lazy" decoding="async">
      <div><strong>Target</strong></div>
      <div id="target-name" style="font-weight: 600;"></div>
    </div>
  </div>

  <div id="navigation-bar" style="margin-top:20px; text-align: center;"></div>
  <div id="choices" class="choices-grid"></div>
  <div id="path" class="path"></div>

  <div style="text-align:center;margin-top:20px;">
    <button class="primary" onclick="startNewGame()">New Puzzle</button>
  </div>

</div>
</div>

<div id="win-modal" class="modal hidden">
  <div class="modal-content">
    <p id="win-text"></p>
    <button class="primary" onclick="startNewGame(); closeModal();">
      Play Again
    </button>
  </div>
</div>
</div>

<div data-include="../includes/footer.html"></div>

<script src="../includes/include-html.js" defer></script>
<script src="./data.js" defer></script>

<script defer>
let startPlayer, currentEntity, currentType, targetPlayer;
let path = [];
let selectionMode = "club";
let selectedContext = null;
let availablePlayers = [];
let validPairs = [];
let distanceCache = {};
let graphCacheBuilt = false;
let MIN_MOVES = 4;
let UNLIMITED_MODE = true;
const MAX_MOVES = 6;

/* =============================
   UTIL
============================= */
function overlaps(a, b) {
  return Math.max(a[0], b[0]) <= Math.min(a[1], b[1]);
}

function isManager(name) {
  return !!managers[name];
}

function beginRandomGame() {

  MIN_MOVES = parseInt(document.getElementById("min-moves").value, 10);
  UNLIMITED_MODE = document.getElementById("unlimited-mode").checked;

  resetPlayerPool();
  showScreen("game-container");
  startNewGame();
}

function beginCustomGame() {

  MIN_MOVES = parseInt(document.getElementById("min-moves").value, 10);
  UNLIMITED_MODE = document.getElementById("unlimited-mode").checked;

  populateCustomDropdowns();
  showScreen("mode-screen");
}

function swapPlayers() {

  // Only allow swap if no moves made
  if (path.length > 1) {
    return;
  }

  const temp = startPlayer;
  startPlayer = targetPlayer;
  targetPlayer = temp;

  currentEntity = startPlayer;
  currentType = "player";
  path = [startPlayer];
  selectionMode = "club";
  selectedContext = null;

  render();
}

function populateCustomDropdowns() {

  const startSelect = document.getElementById("custom-start");
  const targetSelect = document.getElementById("custom-target");

  startSelect.innerHTML = "";
  targetSelect.innerHTML = "";

  const validStarts = Object.keys(players).filter(s => {

    const distances = distanceCache[s];
    if (!distances) return false;

return Object.values(distances).some(d =>
  typeof d === "number" && d === MIN_MOVES
);
  });

  validStarts.forEach(name => {
    const option = new Option(name, name);
    startSelect.add(option);
  });

  startSelect.onchange = function () {

    const selectedStart = this.value;
    const distances = distanceCache[selectedStart];

    targetSelect.innerHTML = "";

    Object.entries(distances).forEach(([name, dist]) => {
      if (dist === MIN_MOVES) {
        targetSelect.add(new Option(name, name));
      }
    });
  };

  // Trigger initial target load
  if (validStarts.length > 0) {
    startSelect.value = validStarts[0];
    startSelect.onchange();
  }
}

function updateStartStats() {

  const minMoves = parseInt(
    document.getElementById("min-moves").value,
    10
  );

  const playersList = Object.keys(players);

  if (!Object.keys(distanceCache).length) {
    document.getElementById("total-players-stat").textContent =
      `${playersList.length} players loaded`;
    document.getElementById("total-pairs-stat").textContent =
      `Calculating...`;
    return;
  }

  // 1Ô∏è‚É£ Build all valid pairs
  const validPairs = [];

  for (let i = 0; i < playersList.length; i++) {
    for (let j = i + 1; j < playersList.length; j++) {

      const a = playersList[i];
      const b = playersList[j];

      const dist = distanceCache[a]?.[b];

      if (typeof dist === "number" && dist === minMoves) {
        validPairs.push([a, b]);
      }
    }
  }

  // 2Ô∏è‚É£ Greedy matching to count unique playable puzzles
  const used = new Set();
  let playableCount = 0;

  for (const [a, b] of validPairs) {
    if (!used.has(a) && !used.has(b)) {
      used.add(a);
      used.add(b);
      playableCount++;
    }
  }

  document.getElementById("total-players-stat").textContent =
    `${playersList.length} players loaded`;

  document.getElementById("total-pairs-stat").textContent =
    `${playableCount.toLocaleString()} unique playable ${minMoves}-move puzzles`;
}

function showScreen(screenId) {

  ["start-screen", "mode-screen", "game-container"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add("hidden");
  });

  const target = document.getElementById(screenId);
  if (target) target.classList.remove("hidden");
}

function backToMenu() {
  showScreen("start-screen");
}

function resetPlayerPool(forceRebuild = false) {

  // Always rebuild available players
  availablePlayers = Object.keys(players)
    .filter(p => hasValidConnections(p));

  // Only rebuild full distance cache if forced OR not built yet
  if (forceRebuild || !Object.keys(distanceCache).length) {

    distanceCache = {};

    for (const start of availablePlayers) {
      distanceCache[start] = computeAllShortestPaths(start);
    }
  }
}

function computeAllShortestPaths(startName) {

  const start = { name: startName, type: "player" };
  const queue = [[start, 0]];
  const visited = new Set([startName + "_player"]);

  const result = {};

  while (queue.length) {

    const [node, depth] = queue.shift();
    const key = node.name + "_" + node.type;

    if (node.type === "player" && node.name !== startName) {
      result[node.name] = depth;
    }

    for (const n of getNeighbors(node)) {

      const nKey = n.name + "_" + n.type;

      if (!visited.has(nKey)) {
        visited.add(nKey);
        queue.push([n, depth + 1]);
      }
    }
  }

  return result;
}

/* =============================
   CLUB CONTEXTS (PLAYER OR MANAGER)
============================= */
function getClubContexts(entity) {

  const contexts = [];

  if (currentType === "player") {

    for (const club in players[entity].career) {

      const spells = players[entity].career[club];
      let valid = false;

      spells.forEach(range => {

        const playersList = getPlayersInClubPeriod(club, range)
          .filter(p => p.name !== entity);

        const managersList = getManagersInClubPeriod(club, range);

        if (playersList.length > 0 || managersList.length > 0) {
          valid = true;
        }

      });

      if (valid) contexts.push({ club });
    }

  } else { // manager

    for (const club in managers[entity].career) {

      const spells = managers[entity].career[club];
      let valid = false;

      spells.forEach(range => {

        const playersList = getPlayersInClubPeriod(club, range);

        if (playersList.length > 0) {
          valid = true;
        }

      });

      if (valid) contexts.push({ club });
    }
  }

  return contexts;
}

/* =============================
   PLAYERS IN CLUB PERIOD
============================= */
function getPlayersInClubPeriod(club, range) {
  const res = [];

  for (const p in players) {

    // Skip current entity only if it's a player
    if (currentType === "player" && p === currentEntity) continue;

    if (!players[p].career[club]) continue;

    for (const r of players[p].career[club]) {
      if (overlaps(r, range)) {
        res.push({ name: p, type: "player" });
        break;
      }
    }
  }

  return res;
}

function startRandomMode() {
  document.getElementById("mode-screen").classList.add("hidden");
  startNewGame();
}

function activateCustomMode() {

  document.getElementById("mode-buttons").classList.add("hidden");
  document.getElementById("custom-setup").classList.remove("hidden");

  const startSelect = document.getElementById("custom-start");
  const targetSelect = document.getElementById("custom-target");

  const names = Object.keys(players);

  // Fill start dropdown
  startSelect.innerHTML = "";
  names.forEach(name => {
    const option = document.createElement("option");
    option.value = name;
    option.textContent = name;
    startSelect.appendChild(option);
  });

  // Initially fill target with valid options
  updateTargetOptions();

  // When start changes ‚Üí update target
  startSelect.addEventListener("change", updateTargetOptions);
}

function updateTargetOptions() {

  const start = document.getElementById("custom-start").value;
  const targetSelect = document.getElementById("custom-target");

  targetSelect.innerHTML = "";

  const names = Object.keys(players);

  names.forEach(name => {

    if (name === start) return;

    const length = shortestPathLength(start, name);

    if (length === MIN_MOVES) {
      const option = document.createElement("option");
      option.value = name;
      option.textContent = name;
      targetSelect.appendChild(option);
  }
  });

  // If no valid targets exist
  if (targetSelect.options.length === 0) {
    const option = document.createElement("option");
    option.textContent = "No valid targets available";
    option.disabled = true;
    targetSelect.appendChild(option);
  }
}

function returnToMenu() {

  // Exit fullscreen if active
  if (document.fullscreenElement) {
    document.exitFullscreen();
    document.body.classList.remove("fullscreen");
    document.getElementById("fullscreenBtn").textContent = "Fullscreen";
  }

  // Reset mode screen
  document.getElementById("mode-screen").classList.remove("hidden");

  // Reset custom view
  document.getElementById("custom-setup").classList.add("hidden");
  document.getElementById("mode-buttons").classList.remove("hidden");
}

function startCustomMode() {

  const start = document.getElementById("custom-start").value;
  const target = document.getElementById("custom-target").value;

  if (!start || !target) return;

  startPlayer = start;
  targetPlayer = target;

  currentEntity = start;
  currentType = "player";
  path = [start];
  selectionMode = "club";
  selectedContext = null;

  showScreen("game-container");
  render();
}

function getManagersInClubPeriod(club, range) {
  const res = [];

  for (const m in managers) {

    // Prevent manager self-loop
    if (currentType === "manager" && m === currentEntity) continue;

    if (!managers[m].career[club]) continue;

    for (const r of managers[m].career[club]) {
      if (overlaps(r, range)) {
        res.push({ name: m, type: "manager" });
        break;
      }
    }
  }

  return res;
}

function toggleFullscreen() {
  const btn = document.getElementById("fullscreenBtn");

  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
    document.body.classList.add("fullscreen");
    btn.textContent = "Exit Fullscreen";
  } else {
    document.exitFullscreen();
    document.body.classList.remove("fullscreen");
    btn.textContent = "Fullscreen";
  }
}
function renderChoices(items, mode, append = false) {

  const count = items.length;
  let sizeClass = "large-choice";

  if (count > 16) sizeClass = "small-choice";
  else if (count > 8) sizeClass = "medium-choice";


  const container = document.getElementById("choices");

  if (!append && mode === "club") {
    container.innerHTML = "";
  }

  items.forEach(item => {

    const div = document.createElement("div");
    div.className = `choice-card ${sizeClass}`;

    if (mode === "club") {

      const club = item.club;
      let spells;

      if (currentType === "player") {
        spells = players[currentEntity].career[club];
      } else {
        spells = managers[currentEntity].career[club];
      }

const rangesText = spells
  .map(spell => {
    const s = spell[0];
    const e = spell[1] ?? spell[0];   // ‚Üê fix here
    return s === e ? `${s}` : `${s}‚Äì${e}`;
  })
  .join(", ");

div.innerHTML = `
  <div class="club-item">
    <div class="badge-wrapper">
      <img src="${clubToBadge(club)}" class="club-badge" loading="lazy" decoding="async">
    </div>
    <div class="club-years">${rangesText}</div>
  </div>
`;


      div.onclick = () => {
        selectedContext = club;
        selectionMode = "entity";
        render();
      };

    } else if (mode === "entity") {

      if (item.type === "manager") {
div.innerHTML = `
  <img src="${getImage(item.name)}" class="entity-img" loading="lazy" decoding="async">
  <div class="entity-text">
    <div class="entity-name">${item.name}</div>
    ${item.overlap ? `<div class="entity-years">(${item.overlap})</div>` : ""}
  </div>
`;

      } else {
div.innerHTML = `
  <img src="${getImage(item.name)}" class="entity-img" loading="lazy" decoding="async">
  <div class="entity-text">
    <div class="entity-name">${item.name}</div>
    ${item.overlap ? `<div class="entity-years">(${item.overlap})</div>` : ""}
  </div>
`;


      }

div.onclick = () => {

  currentEntity = item.name;
  currentType = item.type;
  path.push(item.name);

  const movesMade = path.length - 1;

  selectionMode = "club";
  selectedContext = null;

  render();

  if (currentEntity === targetPlayer) {
    checkWin();
    return;
  }

  if (!UNLIMITED_MODE && movesMade >= MAX_MOVES) {
    showLoseModal();
    return;
  }
};


    }

    container.appendChild(div);

  });

  requestAnimationFrame(adjustChoiceGridCompact);
}

function renderNavigation() {
  const nav = document.getElementById("navigation-bar");
  nav.innerHTML = "";

  if (selectionMode === "entity") {
    const btn = document.createElement("button");
    btn.textContent = "‚Üê Back to Clubs";
    btn.className = "back-btn";
    btn.style.border = "2px solid var(--brand)";
    btn.style.padding = "6px 12px";
    btn.style.fontSize = "0.8rem";

    btn.onclick = () => {
      selectionMode = "club";
      selectedContext = null;
      render();
    };

    nav.appendChild(btn);
  }
}

function toggleHowToPlay() {
  const box = document.getElementById("how-to-play");
  const btn = document.getElementById("howto-toggle-btn");

  box.classList.toggle("collapsed");

  const collapsed = box.classList.contains("collapsed");

  // Save state
  localStorage.setItem("howToPlayCollapsed", collapsed);

  // Update icon
  btn.textContent = collapsed ? "+" : "‚àí";
}

function addSectionHeader(text) {
  const header = document.createElement("div");
  header.className = "section-header";
  header.textContent = text;
  document.getElementById("choices").appendChild(header);
}

function shortestPathLength(startName, targetName) {

  const result = findShortestPath(startName, targetName);

  if (!result) return Infinity;

  return result.length - 1;
}

/* =============================
   MAIN RENDER
============================= */
function render() {
  renderNavigation();
  document.getElementById("start-name").textContent = startPlayer;
  document.getElementById("target-name").textContent = targetPlayer;
  document.getElementById("current-player").textContent = currentEntity;
  document.getElementById("current-label").textContent =
  currentType === "manager"
    ? "Current Manager"
    : "Current Player";
  document.getElementById("current-img").src = getImage(currentEntity, currentType);
  document.getElementById("move-count").textContent = Math.max(0, path.length - 1);

  document.getElementById("start-img").src = getImage(startPlayer);
  document.getElementById("target-img").src = getImage(targetPlayer);

  const swapBtn = document.getElementById("swap-btn");

  if (swapBtn) {
    swapBtn.style.display = path.length > 1 ? "none" : "inline-block";
  }

  document.getElementById("path").innerHTML =
    path.map(p => `
      <div class="step">
        <img src="${isManager(p)?getImage(p):getImage(p)}" loading="lazy" decoding="async">
        <span>${p}</span>
      </div>
    `).join("");

  if (selectionMode === "club") {
    renderChoices(getClubContexts(currentEntity), "club");
  }

else if (selectionMode === "entity") {

  const club = selectedContext;
  const container = document.getElementById("choices");
  container.innerHTML = "";

  let playersList = [];
  let managersList = [];

  if (currentType === "player") {

    const playerSpells = players[currentEntity].career[club];

    playerSpells.forEach(pRange => {

      // Players
      for (const p in players) {
        if (p === currentEntity) continue;
        if (!players[p].career[club]) continue;

        players[p].career[club].forEach(oRange => {

          if (overlaps(pRange, oRange)) {

            const overlapStart = Math.max(pRange[0], oRange[0]);
            const overlapEnd = Math.min(pRange[1], oRange[1]);

playersList.push({
  name: p,
  type: "player",
  sortYear: overlapStart,
  overlap: overlapStart === overlapEnd
    ? `${overlapStart}`
    : `${overlapStart}‚Äì${overlapEnd}`
});
          }
        });
      }

      // Managers
      for (const m in managers) {
        if (!managers[m].career[club]) continue;

        managers[m].career[club].forEach(mRange => {

          if (overlaps(pRange, mRange)) {

            const overlapStart = Math.max(pRange[0], mRange[0]);
            const overlapEnd = Math.min(pRange[1], mRange[1]);

managersList.push({
  name: m,
  type: "manager",
  sortYear: overlapStart,
  overlap: overlapStart === overlapEnd
    ? `${overlapStart}`
    : `${overlapStart}‚Äì${overlapEnd}`
});
          }
        });
      }

    });

  } else {

    const managerSpells = managers[currentEntity].career[club];

    managerSpells.forEach(mRange => {

      for (const p in players) {

        if (!players[p].career[club]) continue;

        players[p].career[club].forEach(pRange => {

          if (overlaps(mRange, pRange)) {

            const overlapStart = Math.max(mRange[0], pRange[0]);
            const overlapEnd = Math.min(mRange[1], pRange[1]);

playersList.push({
  name: p,
  type: "player",
  sortYear: overlapStart,
  overlap: overlapStart === overlapEnd
    ? `${overlapStart}`
    : `${overlapStart}‚Äì${overlapEnd}`
});
          }
        });
      }

    });
  }

  // Remove duplicates
  playersList = removeDuplicateEntities(playersList);
  managersList = removeDuplicateEntities(managersList);
  playersList.sort((a, b) => a.sortYear - b.sortYear);
  managersList.sort((a, b) => a.sortYear - b.sortYear);

  if (playersList.length === 0 && managersList.length === 0) {

    const message = document.createElement("div");
    message.className = "dead-end-message";
    message.textContent = "No more players available this way. Try something else.";
    container.appendChild(message);
    return;
  }

  if (playersList.length > 0) {
    addSectionHeader("Players");
    renderChoices(playersList, "entity");
  }

  if (managersList.length > 0 && currentType === "player") {
    addSectionHeader("Managers");
    renderChoices(managersList, "entity", true);
  }
}

}

function removeDuplicateEntities(list) {

  const merged = new Map();

  list.forEach(item => {

    if (!merged.has(item.name)) {
      merged.set(item.name, {
        ...item,
        overlaps: [item.overlap]
      });
    } else {
      merged.get(item.name).overlaps.push(item.overlap);
    }

  });

  return Array.from(merged.values()).map(item => ({
    ...item,
    overlap: item.overlaps.join(", ")
  }));
}

function showRefreshPoolModal() {

  document.getElementById("win-text").innerHTML = `
    All available player combinations have been used.<br><br>
    Would you like to refresh the player pool?
  `;

  const modal = document.getElementById("win-modal");

  const button = modal.querySelector("button");
  button.textContent = "Refresh Pool";

button.onclick = () => {
  resetPlayerPool(true); // force rebuild
  closeModal();
  startNewGame();
};

  modal.classList.remove("hidden");
}

/* =============================
   GAME START
============================= */
function startNewGame() {

  if (availablePlayers.length < 2) {
    showRefreshPoolModal();
    return;
  }

  let possibleStarts = [];

  for (const s of availablePlayers) {

    const distances = distanceCache[s];
    if (!distances) continue;

    const hasValidTarget = availablePlayers.some(p => {
      if (p === s) return false;
      const d = distances[p];
      return typeof d === "number" && d === MIN_MOVES;
    });

    if (hasValidTarget) {
      possibleStarts.push(s);
    }
  }

  if (possibleStarts.length === 0) {
    showRefreshPoolModal();
    return;
  }

  const s = possibleStarts[Math.floor(Math.random() * possibleStarts.length)];
  const distances = distanceCache[s];

  const possibleTargets = availablePlayers.filter(p => {
    if (p === s) return false;
    const d = distances[p];
    return typeof d === "number" && d === MIN_MOVES;
  });

  if (possibleTargets.length === 0) {
    showRefreshPoolModal();
    return;
  }

  const t = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];

  availablePlayers = availablePlayers.filter(p => p !== s && p !== t);

  startPlayer = s;
  targetPlayer = t;

  currentEntity = s;
  currentType = "player";
  path = [s];
  selectionMode = "club";
  selectedContext = null;

  render();
}

function getImage(name, type = null) {

  if (type === "player") return players[name]?.image;
  if (type === "manager") return managers[name]?.image;

  // fallback
  if (players[name]) return players[name].image;
  if (managers[name]) return managers[name].image;

  return "";
}

function clubToBadge(club) {
  return `../../games/badges/${club.toLowerCase().replace(/\s+/g,'')}.png`;
}

function getNeighbors(entity) {

  const neighbors = [];
  const { name, type } = entity;

  if (type === "player") {

    for (const club in players[name].career) {
      const spells = players[name].career[club];

      for (const spell of spells) {

        // Players
        for (const p in players) {
          if (p === name) continue;
          if (!players[p].career[club]) continue;

          for (const otherSpell of players[p].career[club]) {
            if (overlaps(spell, otherSpell)) {
              neighbors.push({ name: p, type: "player" });
              break;
            }
          }
        }

        // Managers
        for (const m in managers) {
          if (!managers[m].career[club]) continue;

          for (const mSpell of managers[m].career[club]) {
            if (overlaps(spell, mSpell)) {
              neighbors.push({ name: m, type: "manager" });
              break;
            }
          }
        }

      }
    }
  }

  else { // manager

    for (const club in managers[name].career) {
      const spells = managers[name].career[club];

      for (const spell of spells) {

        // Players
        for (const p in players) {
          if (!players[p].career[club]) continue;

          for (const pSpell of players[p].career[club]) {
            if (overlaps(spell, pSpell)) {
              neighbors.push({ name: p, type: "player" });
              break;
            }
          }
        }

        // Managers
        for (const m in managers) {
          if (m === name) continue;
          if (!managers[m].career[club]) continue;

          for (const mSpell of managers[m].career[club]) {
            if (overlaps(spell, mSpell)) {
              neighbors.push({ name: m, type: "manager" });
              break;
            }
          }
        }

      }
    }
  }

  return neighbors;
}

function hasValidConnections(playerName) {

  const start = { name: playerName, type: "player" };
  const neighbors = getNeighbors(start);

  return neighbors.some(n => {
    const second = getNeighbors(n);
    return second.length > 0;
  });
}

function findShortestPath(startName, targetName) {

  const start = { name: startName, type: "player" };
  const targetKey = targetName + "_player";

  const queue = [[start]];
  const visited = new Set([start.name + "_player"]);

  while (queue.length) {

    const path = queue.shift();
    const current = path[path.length - 1];
    const key = current.name + "_" + current.type;

    if (key === targetKey) return path;

    const neighbors = getNeighbors(current);

    for (const neighbor of neighbors) {

      const neighborKey = neighbor.name + "_" + neighbor.type;

      if (!visited.has(neighborKey)) {
        visited.add(neighborKey);
        queue.push([...path, neighbor]);
      }
    }
  }

  return null;
}

function checkWin() {

  const currentName =
    typeof currentEntity === "string"
      ? currentEntity
      : currentEntity?.name;

  if (!currentName) return;
  if (currentName !== targetPlayer) return;

  const moves = path.length - 1;

  const shortest = findShortestPath(startPlayer, targetPlayer);

  let optimalText = "";

  if (shortest) {
    optimalText = shortest.map(n => n.name).join(" ‚Üí ");
  }

  document.getElementById("win-text").innerHTML = `
    üéâ <strong>Connection Complete!</strong><br><br>
    You connected them in <strong>${moves}</strong> moves.<br><br>
    <strong>Shortest possible path:</strong><br>
    ${optimalText}
  `;

  const modal = document.getElementById("win-modal");

  const button = modal.querySelector("button");
  button.textContent = "Play Again";
  button.onclick = () => {
    closeModal();
    startNewGame();
  };

  modal.classList.remove("hidden");
}


function showLoseModal() {

  const shortest = findShortestPath(startPlayer, targetPlayer);

  let optimalText = "";

  if (shortest) {
    optimalText = shortest.map(n => n.name).join(" ‚Üí ");
  }

  document.getElementById("win-text").innerHTML = `
    ‚ùå You ran out of moves.<br><br>
    <strong>Shortest possible path:</strong><br>
    ${optimalText}
  `;

  const modal = document.getElementById("win-modal");

  const button = modal.querySelector("button");
  button.textContent = "Try Again";
  button.onclick = () => {
    closeModal();
    startNewGame();
  };

  modal.classList.remove("hidden");
}

function closeModal() {
  document.getElementById("win-modal").classList.add("hidden");
}

window.addEventListener("load", () => {
  const collapsed = localStorage.getItem("howToPlayCollapsed") === "true";
  const box = document.getElementById("how-to-play");
  const btn = document.getElementById("howto-toggle-btn");

  if (collapsed) {
    box.classList.add("collapsed");
    btn.textContent = "+";
  } else {
    btn.textContent = "‚àí";
  }
});

document.addEventListener("fullscreenchange", () => {
  const btn = document.getElementById("fullscreenBtn");

  if (!document.fullscreenElement) {
    document.body.classList.remove("fullscreen");
    btn.textContent = "Fullscreen";
  }
});

document.getElementById("min-moves")
  .addEventListener("change", updateStartStats);

function initialiseGame() {

  if (typeof players === "undefined") {
    console.error("Players not loaded.");
    return;
  }

  resetPlayerPool(true);
  updateStartStats();

  document.getElementById("loading-overlay")?.remove();

  document.getElementById("app").style.visibility = "visible";
}


function adjustChoiceGridCompact() {

  const card = document.querySelector('#game-container .card');
  if (!card) return;

  card.classList.remove('shrink-1', 'shrink-2');

  const viewportHeight = window.innerHeight;

  // First check: does it overflow?
  if (card.scrollHeight <= viewportHeight) return;

  // Apply shrink level 1
  card.classList.add('shrink-1');

  requestAnimationFrame(() => {

    if (card.scrollHeight <= window.innerHeight) return;

    // Still overflowing ‚Üí apply shrink level 2
    card.classList.remove('shrink-1');
    card.classList.add('shrink-2');

  });
}

window.addEventListener('resize', () => {
  adjustChoiceGridCompact();
});

window.addEventListener("DOMContentLoaded", () => {
  initialiseGame();
});

</script>
</body>
</html>