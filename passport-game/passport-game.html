<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Flatchat Passport Quiz</title>
    <link rel="icon" href="../icons/flatchat-small.webp">
    <style>
      :root {
        --primary: #25b6c4;
        --accent: #f2b632;
      }
      
      /* fullscreen helpers are injected in the script area; see JS below */
      * { box-sizing: border-box; }

      body {
        font-family: "Segoe UI", Arial, sans-serif;
        margin: 0;
        background: #f4f6f9;
        color: #222;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        background-color: var(--primary);
        color: #fff;
        padding: 8px 25px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      }

      .header-container {
        display:flex;
        justify-content:center;
        align-items:center;
        gap:40px;
        max-width:1200px;
        margin:0 auto;
      }

      .header-logo { max-width:520px; height:auto; transition: transform .3s ease, box-shadow .3s ease; }
      .header-logo:hover { transform:scale(1.05); box-shadow:0 10px 25px rgba(0,0,0,0.3); }

      nav { display:flex; align-items:center; }
      nav a { color:#fff; margin:0 10px; text-decoration:none; font-weight:600; font-size:0.9rem; transition: color .2s ease; }
      nav a:hover { color: var(--accent); }

      @media (max-width:768px) {
        header { padding:6px 12px; }
        .header-container { flex-direction:column; text-align:center; gap:6px; }
        .header-logo { max-width:85%; }
        nav { flex-wrap:wrap; justify-content:center; gap:4px; }
        nav a { display:inline-block; margin:3px; font-size:0.85rem; }
        header + header { padding:4px 12px !important; font-size:0.75rem !important; line-height:1.3 !important; }
        footer { padding:8px 10px; font-size:0.8rem; }
        footer p { margin:0 0 4px; }
        .social-links { margin-top:4px; }
        .social-links img { width:28px; height:28px; }
        h5 { font-size:0.7rem !important; margin:4px 0 !important; line-height:1.3 !important; }
      }

      footer {
        background-color: var(--primary);
        color:#fff;
        text-align:center;
        padding:10px 15px;
        font-size:0.9rem;
        box-shadow:0 -2px 8px rgba(0,0,0,0.2);
        position: relative;
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:center;
      }
      footer p { margin:0 0 8px; line-height:1.4; }

      .social-links { margin-top:6px; }
      .social-links a { display:inline-block; margin:0 8px; text-decoration:none; transition: transform .3s ease; }
      .social-links img { width:36px; height:36px; object-fit:cover; transition: transform .3s ease; }
      .social-links img:hover { transform:scale(1.1); }

      .footer-random { position:absolute; bottom:10px; right:20px; z-index:10; }
      #randomMomentBtn {
        background:#f5f5f5; border:none; border-radius:50%; cursor:pointer; padding:6px;
        box-shadow:0 2px 6px rgba(0,0,0,0.25); transition: transform .3s ease, box-shadow .3s ease;
      }
      #randomMomentBtn:hover { transform:rotate(15deg) scale(1.1); box-shadow:0 4px 10px rgba(0,0,0,0.3); }
      #randomMomentBtn img { width:48px; height:48px; border-radius:50%; display:block; }

      @media (max-width:768px) {
        .footer-random { position:static; margin-top:10px; display:flex; justify-content:center; }
        #randomMomentBtn img { width:42px; height:42px; }
      }

      main {
        flex:1;
        width:96%;
        max-width:1600px;
        margin:20px auto;
        padding:32px 28px;
        background:transparent;
        border-radius:12px;
        box-shadow:0 6px 25px rgba(0,0,0,.08);
        display:flex;
        flex-direction:column;
        gap:20px;
        position:relative;
      }

      h2 { margin:0; text-align:center; font-size:2.2rem; color:#0a7785; }
      h3 { font-size:1.3rem; color:#333; margin:8px 0; }

      #round-stats { text-align:center; font-weight:700; color:#0a7785; margin-top:8px; font-size:1.1rem; }
      #players-grid {
        display:grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap:24px;
        margin-top:16px;
        margin-bottom:32px;
      }

      .player-card { perspective:1000px; position:relative; display:block; min-height:360px; }
      .card-inner { width:100%; transform-style:preserve-3d; transition: transform .8s cubic-bezier(.25,.9,.35,1.3); display:grid; }
      .card-inner > * { min-height:auto; }
      .player-card.hidden .card-inner { transform:rotateY(180deg); }
      .player-card:not(.hidden):hover .card-inner { transform:scale(1.03); }

      /* When we temporarily disable scaling during interactions, prevent
         card hover/scale and transitions from changing layout. JS will add
         `no-scale` to the body while a stat is being placed. */
      body.no-scale .player-card:not(.hidden) .card-inner {
        transform: none !important;
        transition: none !important;
      }
      body.no-scale .scale-wrap {
        transition: none !important;
      }

      .card-front, .card-back {
        grid-area: 1/1;
        width:100%;
        backface-visibility:hidden;
        display:flex;
        flex-direction:column;
        align-items:center;
        text-align:center;
      }
      .card-front { background:#e4f9ff; padding-top:14px; padding-bottom:14px; }
      .card-front img {
        width:280px; height:280px; object-fit:cover; border-radius:10px; box-shadow:0 4px 10px rgba(0,0,0,.16);
      }

      .player-name { display:none; margin-top:10px; font-weight:800; color:#0a7785; text-align:center; font-size:1.05rem; transition: opacity .28s, transform .28s; opacity:0; transform:translateY(6px); }

      .player-select {
        display:none;
        margin-top:8px;
        font-weight:700;
        color:#0a7785;
        text-align:center;
        font-size:1rem;
        padding:10px 12px;
        border-radius:8px;
        border:2px solid rgba(10,119,133,0.08);
        background:#fff;
        transition: opacity .28s, transform .28s;
        opacity:0; transform:translateY(6px); appearance:none;
      }
      .player-select.revealed { display:block; opacity:1; transform:translateY(0); }

      .player-select.wrong { outline:3px solid #ff4f4f; box-shadow:0 4px 12px rgba(255,79,79,0.12); color:#b91c1c; }
      .player-select.correct { outline:3px solid #32d74b; box-shadow:0 4px 12px rgba(50,215,75,0.08); color:#087f5b; }

      .user-guess {
        display:inline-block; margin-left:8px; padding:4px 8px; border-radius:8px; background:rgba(185,28,28,0.06);
        color:#b91c1c; font-weight:700; font-size:0.85rem; vertical-align:middle; transition: opacity .36s, transform .36s;
      }
      .user-guess.faded { opacity:0; transform: translateY(-6px); }

      .card-back {
        background: var(--primary);
        color: #fff;
        transform: rotateY(180deg);
        display:flex;
        align-items:center;
        justify-content:center;
        font-size:1.2rem;
      }

      .drop-zone {
        width:94%; min-height:130px; margin-top:14px; padding:12px;
        border:2px dashed #20a5b8; border-radius:10px; background:#fff;
        display:flex; flex-wrap:wrap; gap:10px; align-content:flex-start;
      }

      .drop-zone:hover { background:#fff7d1; border-color:var(--accent); }

      #stats-pool { 
        display:flex; 
        flex-wrap:wrap; 
        gap:14px; 
        padding:16px 8px 36px; 
        border-top:3px solid #e6e6e6; 
        justify-content:center; 
        background:#fff;
      }

      /* Mobile sticky stats tray */
      @media (max-width:768px) {
        #stats-pool {
          position:sticky;
          bottom:0;
          z-index:100;
          border-top:3px solid var(--primary);
          box-shadow:0 -4px 12px rgba(0,0,0,0.15);
          padding:8px 6px 12px;
          margin-top:12px;
          max-height:30vh;
          overflow-y:auto;
          -webkit-overflow-scrolling:touch;
        }
        /* Add padding to bottom of content to prevent overlap */
        main .scale-wrap {
          padding-bottom:12px;
        }
      }

      .stat {
        padding:12px 16px; border-radius:10px; font-weight:700; font-size:1.05rem; cursor:pointer;
        box-shadow:0 3px 10px rgba(0,0,0,.12); user-select:none; -webkit-user-drag:none;
        transition: transform .12s, opacity .12s; display:inline-block; word-break:break-word; max-width:100%;
      }
      .stat:hover { transform:scale(1.06); }
      .stat.selected { outline:3px solid #0a7785; transform:scale(1.03); }
      .stat.placing { animation: placePop .35s cubic-bezier(.2,.9,.2,1); }
      .stat.placed { animation: popIn .45s ease-out; }
      .stat.correct { outline:3px solid #32d74b; }
      .stat.wrong { outline:3px solid #ff4f4f; }

      .controls { display:flex; gap:16px; flex-wrap:wrap; justify-content:center; align-items:center; margin-top:8px; }
      main:fullscreen .controls,
      main:-webkit-full-screen .controls {
        max-width:100% !important;
        width:100% !important;
        box-sizing:border-box !important;
        display:flex !important;
        visibility:visible !important;
        opacity:1 !important;
      }

      .btn {
        padding:12px 22px; border-radius:8px; border:none; font-weight:700; font-size:1.05rem; cursor:pointer;
        transition: transform .2s ease, box-shadow .2s ease;
      }
      .btn:hover { transform: translateY(-2px); box-shadow:0 4px 12px rgba(0,0,0,0.15); }

      .btn-reset { background: var(--accent); }
      .btn-submit { background: var(--primary); color:#fff; }

      .legend-chip { display:inline-block; padding:8px 14px; margin:6px; border-radius:8px; font-weight:700; font-size:1.05rem; color:#111; box-shadow:0 2px 6px rgba(0,0,0,.08); }

      #score-output { text-align:center; font-weight:700; margin-top:16px; font-size:1.15rem; color:#0a7785; }

      main:fullscreen { 
        width:100vw !important; 
        max-width:none !important; 
        height:100vh !important; 
        margin:0 !important; 
        padding:0 !important; 
        background:#f4f6f9 !important; 
        border-radius:0 !important; 
        overflow:hidden !important; 
        display:flex !important;
        flex-direction:column !important;
        align-items:center !important;
        justify-content:center !important;
      }
      main:-webkit-full-screen { 
        width:100vw !important; 
        max-width:none !important;
        height:100vh !important; 
        margin:0 !important; 
        padding:0 !important; 
        background:#f4f6f9 !important; 
        border-radius:0 !important; 
        overflow:hidden !important;
        display:flex !important;
        flex-direction:column !important;
        align-items:center !important;
        justify-content:center !important;
      }

      /* Fullscreen banner: positioned above the main section in the top margin */
      main:fullscreen::before,
      main:-webkit-full-screen::before {
        content: '';
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        top: 18px; /* small offset into the top margin */
        width: min(1200px, 86%);
        height: 92px;
        background-image: url('icons/flatchat_banner.jpg');
        background-repeat: no-repeat;
        background-position: center center;
        background-size: contain;
        border: 6px solid #ffffff; /* white border */
        border-radius: 12px;
        box-shadow: 0 6px 20px rgba(0,0,0,0.06);
        z-index: 100001;
        pointer-events: none;
      }
      main:fullscreen .scale-wrap {
        max-width:calc(100vw - 36px) !important;
        border:6px solid var(--primary) !important;
        padding:12px !important;
        display:flex !important;
        flex-direction:column !important;
        overflow:visible !important;
        transform-origin:center center !important;
        margin:auto !important;
        position:relative !important;
        box-sizing:border-box !important;
        transition:none !important;
        will-change:transform !important;
        backface-visibility:hidden !important;
      }
      main:-webkit-full-screen .scale-wrap {
        max-width:calc(100vw - 36px) !important;
        border:6px solid var(--primary) !important;
        padding:12px !important;
        display:flex !important;
        flex-direction:column !important;
        overflow:visible !important;
        transform-origin:center center !important;
        margin:auto !important;
        position:relative !important;
        box-sizing:border-box !important;
        transition:none !important;
        will-change:transform !important;
        backface-visibility:hidden !important;
      }

      #fullscreenBtn {
        z-index:9999; padding:10px 14px; border-radius:8px; background:rgba(0,0,0,0.75); color:#fff; border:none;
        position:absolute; top:12px; left:12px; transform:none !important; min-width:44px; min-height:44px; padding:8px 12px;
        cursor:pointer;
      }
      /* Hide fullscreen button on mobile */
      @media (max-width:768px) {
        #fullscreenBtn {
          display:none !important;
        }
      }
      /* Hide fullscreen button in fullscreen mode */
      main:fullscreen #fullscreenBtn,
      main:-webkit-full-screen #fullscreenBtn {
        display:none !important;
      }

      /* Exit fullscreen button (shown while in fullscreen) â€” left, same as fullscreen button */
      #exitFullscreenBtn { display:none; }
      main:fullscreen #exitFullscreenBtn,
      main:-webkit-full-screen #exitFullscreenBtn {
        display:block !important;
        position: absolute !important;
        top: 12px !important;
        left: 12px !important;
        z-index: 9999 !important;
        min-width:44px !important;
        min-height:44px !important;
        background: rgba(0,0,0,0.75) !important;
        color: #fff !important;
        border: none !important;
      }
      @media (max-width:768px) {
        #exitFullscreenBtn { display:none !important; }
      }
      
      /* Hide all direct children of main except scale-wrap in fullscreen */
      main:fullscreen > *:not(.scale-wrap),
      main:-webkit-full-screen > *:not(.scale-wrap) {
        display:none !important;
      }

      .scale-wrap {
        transform-origin: top center;
        transition: transform .18s ease;
        width:100%;
        position:relative;
        box-sizing:border-box;
        border:6px solid var(--primary);
        border-radius:12px;
        background:#fff;
        box-shadow:0 6px 20px rgba(0,0,0,0.06);
        padding:18px;
      }

      @media (max-width:768px) {
        main { padding:12px 8px; width:100%; margin:8px auto; gap:8px; }
        h2 { font-size:1.4rem; margin:4px 0; }
        h3 { font-size:1rem; margin:4px 0; }
        h4 { font-size:0.85rem; margin:4px 0; line-height:1.3; }
        #round-stats { font-size:0.9rem; margin-top:4px; }
        #players-grid { 
          grid-template-columns: repeat(4, 1fr);
          gap:6px;
          margin-top:8px;
          margin-bottom:12px;
          overflow-x: auto;
          -webkit-overflow-scrolling: touch;
        }
        .player-card { min-height:200px; }
        .card-front { padding-top:6px; padding-bottom:6px; }
        .card-front img { width:80px; height:80px; }
        .select-wrap { gap:3px !important; }
        .clear-select { width:22px; height:22px; font-size:0.8rem; }
        .drop-zone { 
          width:90%; 
          min-height:60px; 
          margin-top:6px; 
          padding:6px; 
          gap:4px;
        }
        .stat { padding:6px 8px; font-size:0.75rem; border-radius:8px; }
        .legend-chip { padding:3px 6px; font-size:0.75rem; margin:2px; }
        .player-select { font-size:0.75rem; padding:4px 6px; margin-top:3px; }
        .controls { gap:8px; margin-top:4px; flex-direction:column; }
        .controls label { flex-direction:column; align-items:flex-start; gap:4px; }
        .controls select { width:100%; margin-left:0 !important; }
        .btn { padding:10px 16px; font-size:0.9rem; }
        #score-output { font-size:0.95rem; margin-top:8px; }
        .scale-wrap { padding:12px 8px; }
        /* Compact stats tray */
        #stats-pool {
          padding:6px 4px 10px;
          gap:6px;
          max-height:30vh;
        }
      }

      @media (max-width:480px) {
        main { padding:8px 6px; gap:6px; }
        h2 { font-size:1.2rem; margin:3px 0; }
        h3 { font-size:0.9rem; margin:3px 0; }
        h4 { font-size:0.75rem; margin:3px 0; line-height:1.3; }
        #round-stats { font-size:0.8rem; margin-top:3px; }
        #players-grid { 
          grid-template-columns: repeat(2, 1fr);
          gap:6px;
          margin-top:6px;
          margin-bottom:8px;
        }
        .player-card { min-height:180px; }
        .card-front { padding-top:4px; padding-bottom:4px; }
        .card-front img { width:90px; height:90px; }
        .select-wrap { gap:2px !important; }
        .clear-select { width:20px; height:20px; font-size:0.75rem; }
        .drop-zone { 
          min-height:50px; 
          margin-top:4px;
          padding:4px;
          gap:3px;
        }
        .stat { padding:5px 6px; font-size:0.7rem; border-radius:6px; }
        .legend-chip { padding:2px 5px; font-size:0.7rem; margin:2px; }
        .player-select { font-size:0.7rem; padding:3px 5px; margin-top:2px; }
        .btn { padding:8px 12px; font-size:0.85rem; }
        #score-output { font-size:0.85rem; margin-top:6px; }
        .scale-wrap { padding:8px 6px; }
        #stats-pool {
          padding:5px 3px 8px;
          gap:4px;
          max-height:28vh;
          margin-top:8px;
        }
        .controls { gap:6px; margin-top:3px; }
        main .scale-wrap {
          padding-bottom:10px;
        }
      }

      .diff-tooltip {
        background:#fff;
        border:1px solid rgba(0,0,0,0.08);
        box-shadow:0 6px 20px rgba(0,0,0,0.12);
        border-radius:8px;
        color:#111;
        font-size:0.9rem;
        transform-origin:bottom center;
        padding:8px 10px;
      }
      .diff-tooltip ul li { margin:6px 0; line-height:1.25; }

      #diffInfoBtn { width:34px; height:34px; padding:0; border-radius:8px; background:#eee; font-weight:800; }

      @media (max-width:520px) { .diff-tooltip { left:auto; right:0; min-width:200px; } }

      .clear-select {
        background:transparent; border:1px solid rgba(0,0,0,0.06); width:30px; height:30px; border-radius:6px; font-weight:800; cursor:pointer;
        display:inline-flex; align-items:center; justify-content:center; color:#333;
      }
      .clear-select:hover { background:rgba(0,0,0,0.04); }

      /* Anchor wrapper for lock-in tooltip */
      .lockin-wrap { position: relative; display: inline-block; }

      @keyframes placePop {
        0% { transform: scale(.85); opacity: .7 }
        60% { transform: scale(1.08) }
        100% { transform: scale(1); opacity: 1 }
      }
      @keyframes popIn {
        0% { opacity:0; transform: scale(.55) rotate(-8deg) }
        60% { opacity:1; transform: scale(1.12) rotate(4deg) }
        100% { transform: scale(1) rotate(0) }
      }

    </style>
  </head>
  <body>
  <div data-include="../includes/header.html"></div>
    

    <header style="text-align:center; padding:8px 24px;">
      This is a fan site made with the purpose of collating funny and iconic moments for the benefit of other flatchat fans. Click through the lads profiles to find their best moments.
    </header>

    <main>
      <div class="scale-wrap">
        <button id="fullscreenBtn" class="btn" style="background:#222;color:#fff;"> â›¶ Fullscreen </button>
        <button id="exitFullscreenBtn" class="btn" style="background:#222;color:#fff;"> âœ• Exit Fullscreen </button>

        <h2>Flatchat Passport Game</h2>
        <h3 style="text-align:center;">
          Match the stats to the players and guess their names! (Simply click the stat and place)
        </h3>
        <h4 style="text-align:center;">
          Choose your difficulty - harder = more points! All data from Wikipedia. Good luck! ðŸ™‚
        </h4>

        <div id="round-stats">Loading...</div>
        <div id="current-difficulty" style="text-align:center;font-weight:700;color:#0a7785;margin-top:4px;font-size:1rem;"></div>
        <div id="players-grid"></div>

        <h3 style="text-align:center;">Stats to place:</h3>
        <div id="stats-pool"></div>

        <!-- Controls block - rebuilt and cleaned -->
        <div class="controls">
          <label style="display:flex;align-items:center;gap:8px;font-weight:700">
            Difficulty:
            <select id="difficultySelect" style="padding:8px;border-radius:6px;margin-left:8px">
              <option value="easy">Easy (No Multiplier)</option>
              <option value="hard">Hard (x1.5 points)</option>
              <option value="very-hard">Very Hard (x2 points)</option>
              <option value="extreme">Extreme (x3 points)</option>
            </select>

            <div class="diff-tooltip-wrap" style="position:relative;display:inline-block;margin-left:8px">
              <button id="diffInfoBtn" aria-expanded="false" aria-controls="diffTooltip" class="btn" style="margin-left:8px;padding:6px 8px;">i</button>
              <div id="diffTooltip" role="tooltip" aria-hidden="true" class="diff-tooltip" style="display:none;position:fixed;z-index:200;min-width:240px;">
                <ul style="margin:0;padding:10px 12px;list-style:none;">
                  <li><strong>Easy (No Multiplier)</strong>: The most well-known footballers, should know every player. (20 points available)</li>
                  <li><strong>Hard (x1.5 points)</strong>: Lesser-known top division ballers, should know most of the players. (30 points available)</li>
                  <li><strong>Very Hard (x2 points)</strong>: Obscure top division ballers or better-known non top 5 league players, should know some of the players. (40 points available)</li>
                  <li><strong>Extreme (x3 points)</strong>: Forgotten ballers that made no impact on the game, maybe you'll know 1 player. (60 points available)</li>
                </ul>
              </div>
            </div>
          </label>

          <button id="resetGame" class="btn btn-reset" style="margin-left:8px">ðŸ”„ Start New Round</button>

          <!-- Lock-in wrapper: tooltip is positioned relative to this -->
          <div class="lockin-wrap" style="margin-left:8px;">
            <button id="submitAnswers" class="btn btn-submit" aria-disabled="true" disabled>Lock-In</button>

            <div id="submitDisabledTip" role="tooltip" aria-hidden="true" class="diff-tooltip" style="display:none; position:absolute; left:105%; top:50%; transform:translateY(-50%); z-index:40; min-width:220px; padding:8px 10px; white-space:normal;">
            </div>
          </div>
        </div>

        <div id="score-output"></div>
      </div>
      <h5 style="text-align:center;">
        Massive thanks to ADM101010 for being the worlds greatest quality assurance and Kyle Mathewson and Melissa too for playtesting and providing feedback. 
      </h5>
    </main>

    <div data-include="../includes/footer.html"></div>

    <!-- keep your external helpers unchanged -->
    <script src="../scripts/modal-auto-stop-video.js"></script>
    <script src="../scripts/randomMoment.js"></script>

    <!-- Consolidated & cleaned game script -->
    <script>
      /* =====================================================
         DATA PLACEHOLDERS
         ===================================================== */
      let STAT_COLORS = {};
      let EASY_PLAYERS = [];
      let HARD_PLAYERS = [];
      let VERY_HARD_PLAYERS = [];
      let EXTREME_PLAYERS = [];

      /* =====================================================
         DOM SHORTCUTS + STATE
         ===================================================== */
      const grid = document.getElementById("players-grid");
      const pool = document.getElementById("stats-pool");
      const diffSel = document.getElementById("difficultySelect");
      const roundStats = document.getElementById("round-stats");
      const scoreOut = document.getElementById("score-output");

      let chosenPlayers = [];
      let activeKeys = [];
      let statBank = [];
      let lastRoundPlayers = [];
      let lockedNameScore = 0;
      let isLocked = false;
      let lockedCombinedPoints = 0;
      let lockedMaxCombined = 0;
      let lockedCombinedCount = 0;
      let lockedStatsScore = 0;

      let updatePlayerSelects = null; // will hold ref to select-updater

      function shuffle(arr) { return arr.slice().sort(() => Math.random() - 0.5); }
      function getDifficultyMultiplier() {
        const d = diffSel.value;
        if (d === 'hard') return 1.5;
        if (d === 'very-hard') return 2;
        if (d === 'extreme') return 3;
        return 1;
      }
      
      function updateDifficultyDisplay() {
        const diffDisplay = document.getElementById('current-difficulty');
        if (!diffDisplay) return;
        const d = diffSel.value;
        const multiplier = getDifficultyMultiplier();
        let diffName = '';
        if (d === 'easy') diffName = 'Easy';
        else if (d === 'hard') diffName = 'Hard';
        else if (d === 'very-hard') diffName = 'Very Hard';
        else if (d === 'extreme') diffName = 'Extreme';
        
        const multiplierText = multiplier === 1 ? 'No Multiplier' : `Ã—${multiplier} points`;
        diffDisplay.textContent = `Selected Difficulty: ${diffName} (${multiplierText})`;
      }

/* =====================================================
   USED PLAYER TRACKING (localStorage)
   ===================================================== */

function getUsedKey(diff) {
  return `usedPlayers_${diff}`;
}

function getUsedPlayers(diff) {
  try {
    return JSON.parse(localStorage.getItem(getUsedKey(diff))) || [];
  } catch {
    return [];
  }
}

function addUsedPlayers(diff, names) {
  const used = new Set(getUsedPlayers(diff));
  names.forEach(n => used.add(n));
  localStorage.setItem(getUsedKey(diff), JSON.stringify([...used]));
}

function clearUsedPlayers(diff) {
  localStorage.removeItem(getUsedKey(diff));
}


      /* =====================================================
         LOAD PLAYERS
         ===================================================== */
      async function loadPlayerData() {
        try {
          const response = await fetch("passport-game-data/players.json");
          const data = await response.json();
          STAT_COLORS = data.STAT_COLORS || {};
          EASY_PLAYERS = data.EASY_PLAYERS || [];
          HARD_PLAYERS = data.HARD_PLAYERS || [];
          VERY_HARD_PLAYERS = data.VERY_HARD_PLAYERS || [];
          EXTREME_PLAYERS = data.EXTREME_PLAYERS || [];
        } catch (err) {
          console.error("Failed to load players.json", err);
        }
        setupGame();
      }

      /* =====================================================
         SETUP + RENDER
         ===================================================== */
      function setupGame() {
        grid.innerHTML = "";
        pool.innerHTML = "";
        scoreOut.textContent = "";
        isLocked = false;

        updateDifficultyDisplay();
        roundStats.textContent = "Loadingâ€¦";

        // Choose pool & counts based on difficulty
        let basePool = EASY_PLAYERS;
        let playerCount = 4;
        let keyCount = 4;
        const diff = diffSel.value;

        if (diff === 'easy') {
          basePool = EASY_PLAYERS; playerCount = 4; keyCount = 4;
        } else if (diff === 'hard') {
          basePool = HARD_PLAYERS; playerCount = 4; keyCount = 4;
        } else if (diff === 'very-hard') {
          basePool = VERY_HARD_PLAYERS.length ? VERY_HARD_PLAYERS : HARD_PLAYERS;
          playerCount = 4; keyCount = 4;
        } else if (diff === 'extreme') {
          basePool = EXTREME_PLAYERS.length ? EXTREME_PLAYERS : (VERY_HARD_PLAYERS.length ? VERY_HARD_PLAYERS : HARD_PLAYERS);
          playerCount = 4; keyCount = 4;
        }

const diffKey = diffSel.value;
const used = new Set(getUsedPlayers(diffKey));

let available = basePool.filter(p => !used.has(p.name));

if (available.length < playerCount) {
  grid.innerHTML = `
    <div style="grid-column:1/-1;text-align:center;padding:40px;">
      <h3>ðŸš« No more players available</h3>
      <p>You have rolled all available players for <b>${diffKey}</b> difficulty in this browser.</p>
      <button class="btn btn-reset" id="clearUsedBtn">Reset this difficulty</button>
    </div>
  `;
  pool.innerHTML = '';
  roundStats.textContent = '';
  scoreOut.textContent = '';

  document.getElementById('clearUsedBtn').addEventListener('click', () => {
    clearUsedPlayers(diffKey);
    setupGame();
  });
  return;
}

chosenPlayers = shuffle(available).slice(0, playerCount);

        const availableKeys = Object.keys(chosenPlayers[0].stats || {});
        activeKeys = shuffle(availableKeys).slice(0, Math.min(keyCount, availableKeys.length));

        statBank = [];
        chosenPlayers.forEach(p => {
          activeKeys.forEach(k => {
            statBank.push({ player: p.name, key: k, value: p.stats[k] });
          });
        });

        lastRoundPlayers = chosenPlayers.map(p => p.name);

        addUsedPlayers(diffSel.value, lastRoundPlayers);

        // build cards
        chosenPlayers.forEach(p => {
          const card = document.createElement("div");
          card.className = "player-card hidden";
          card.dataset.player = p.name;
          card.innerHTML = `
            <div class="card-inner">
              <div class="card-front">
                <div class="select-wrap" style="display:flex;align-items:center;gap:8px;">
                  <select class="player-select" aria-hidden="true">
                    <option value="">Select player</option>
                  </select>
                  <button class="clear-select" title="Clear selection" style="display:none;">Ã—</button>
                </div>
                <img src="${p.image}">
                <div class="drop-zone" data-owner="${p.name}"></div>
              </div>
              <div class="card-back"></div>
            </div>`;
          grid.appendChild(card);
        });

        // stat pool
        const shuffledBank = shuffle(statBank);
        pool.innerHTML = shuffledBank.map(s => {
          const bg = STAT_COLORS[s.key] || "#25b6c4";
          const color = bg === "#25b6c4" ? "#fff" : "#111";
          return `<div class="stat" data-player="${s.player}" data-key="${s.key}" style="background:${bg};color:${color}">${s.value}</div>`;
        }).join('');

        // legend
        roundStats.innerHTML = activeKeys.map(k => {
          const bg = STAT_COLORS[k] || "#25b6c4";
          const c = bg === "#25b6c4" ? "#fff" : "#111";
          return `<span class="legend-chip" style="background:${bg};color:${c}">${k}</span>`;
        }).join(" ");

        revealCards();

        setTimeout(() => {
          const names = shuffle(chosenPlayers.map(x => x.name));
          wirePlayerSelects(names);

          document.querySelectorAll('.player-select').forEach(sel => {
            sel.classList.add('revealed');
            sel.disabled = false;
          });

          attachPointerDrag();
          updateSubmitState();
        }, 250);
      }

      diffSel.addEventListener('change', () => {
        // show Lock-In if it was hidden earlier
        const submitBtnEl = document.getElementById('submitAnswers');
        if (submitBtnEl) submitBtnEl.style.display = '';
        updateDifficultyDisplay();
        setupGame();
      });

      function revealCards() {
        const cards = [...document.querySelectorAll(".player-card")];
        cards.forEach(c => c.classList.add("hidden"));
        setTimeout(() => {
          cards.forEach((c, i) => setTimeout(() => c.classList.remove("hidden"), i * 220));
          setTimeout(() => attachPointerDrag(), 1200);
        }, 200);
      }

      /* =====================================================
         SELECT WIRING: unique options + clear buttons
         ===================================================== */
      function wirePlayerSelects(names) {
        const selects = Array.from(document.querySelectorAll('.player-select'));

        function update() {
          const chosen = selects.map(s => s.value).filter(v => v);
          selects.forEach(sel => {
            const current = sel.value;
            const options = ['<option value="">Select player</option>'];
            names.forEach(n => {
              if (n === current || !chosen.includes(n)) options.push(`<option value="${n}">${n}</option>`);
            });
            sel.innerHTML = options.join('');
            sel.value = current || '';
            const clearBtn = sel.parentElement.querySelector('.clear-select');
            if (clearBtn) clearBtn.style.display = sel.value ? 'inline-flex' : 'none';
          });
          updateSubmitState();
        }

        selects.forEach(s => s.addEventListener('change', update));
        selects.forEach(sel => {
          const btn = sel.parentElement.querySelector('.clear-select');
          if (!btn) return;
          btn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            sel.value = '';
            update();
            updateSubmitState();
            sel.focus();
          });
        });

        updatePlayerSelects = update;
        update();
        updateSubmitState();
        return update;
      }

      function setClearButtonsVisible(visible) {
        document.querySelectorAll('.clear-select').forEach(b => {
          b.style.display = visible ? 'inline-flex' : 'none';
          b.disabled = !visible;
        });
      }

      /* =====================================================
         POOL / DROP-ZONE INTERACTIONS (click-to-place)
         ===================================================== */
      let selectedTile = null;

      function attachPointerDrag() {
        const tiles = [...document.querySelectorAll("#stats-pool .stat")];
        tiles.forEach(tile => {
          tile.style.touchAction = "manipulation";
          tile.removeEventListener('click', tileClick);
          tile.addEventListener('click', tileClick);
        });

        const zones = [...document.querySelectorAll('.drop-zone')];
        zones.forEach(z => {
          z.removeEventListener('click', zoneClick);
          z.addEventListener('click', zoneClick);
        });

        const cards = [...document.querySelectorAll('.player-card')];
        cards.forEach(card => {
          card.style.touchAction = 'manipulation';
          card.removeEventListener('click', cardClickHandler);
          card.addEventListener('click', cardClickHandler);
        });
      }

      function cardClickHandler(e) {
        if (e.target.closest('.stat')) return;
        const zone = this.querySelector('.drop-zone');
        if (!zone) return;
        zoneClick({ currentTarget: zone, stopPropagation: () => {} });
      }

      function tileClick(e) {
        e.stopPropagation();
        const tile = e.currentTarget;
        if (isLocked) return;

        const parent = tile.parentElement;
        if (parent && parent.classList && parent.classList.contains('drop-zone')) {
          const poolEl = document.getElementById('stats-pool');
          tile.classList.remove('placed', 'selected', 'correct', 'wrong');
          try { delete tile.dataset.userPlaced; } catch (err) {}
          poolEl.appendChild(tile);
          updateSubmitState();
          return;
        }

        if (selectedTile) selectedTile.classList.remove('selected');
        if (selectedTile === tile) {
          selectedTile = null;
        } else {
          selectedTile = tile;
          selectedTile.classList.add('selected');
        }
      }

      function zoneClick(e) {
        const zone = e.currentTarget;
        if (!selectedTile) return;
        if (isLocked) return;

        const key = selectedTile.dataset.key;
        const existingEl = Array.from(zone.querySelectorAll('.stat')).find(s => s.dataset.key === key);
        if (existingEl) {
          const poolEl = document.getElementById('stats-pool');
          existingEl.classList.remove('placed', 'correct', 'wrong');
          try { delete existingEl.dataset.userPlaced; } catch (err) {}
          poolEl.appendChild(existingEl);

          placeTile(zone, selectedTile.dataset.player, selectedTile.dataset.key, selectedTile.textContent.trim(), selectedTile);
          try { selectedTile.dataset.userPlaced = 'true'; } catch (err) {}
          selectedTile.classList.remove('selected');
          selectedTile.classList.add('placed', 'placing');
          setTimeout(() => selectedTile.classList.remove('placing'), 380);
          selectedTile = null;
          return;
        }

        placeTile(zone, selectedTile.dataset.player, selectedTile.dataset.key, selectedTile.textContent.trim(), selectedTile);
        try { selectedTile.dataset.userPlaced = 'true'; } catch (err) {}
        selectedTile.classList.remove('selected');
        selectedTile.classList.add('placed', 'placing');
        setTimeout(() => selectedTile.classList.remove('placing'), 380);
        selectedTile = null;
        updateSubmitState();
      }

      function placeTile(zone, p, k, t, originEl) {
        // Temporarily lock scale/transform to prevent visual rescaling while
        // placing a stat tile.
        try { lockWrapDuringPlacement(600); } catch (e) {}

        if (originEl) {
          zone.appendChild(originEl);
          originEl.classList.add('placed');
          originEl.style.touchAction = 'manipulation';
          originEl.removeEventListener('click', tileClick);
          originEl.addEventListener('click', tileClick);
          originEl.classList.add('placing');
          setTimeout(() => originEl.classList.remove('placing'), 380);
          updateSubmitState();
          return;
        }

        const d = document.createElement('div');
        d.className = 'stat placed';
        d.dataset.player = p;
        d.dataset.key = k;
        d.textContent = t;
        const bg = STAT_COLORS[k] || '#25b6c4';
        const c = bg === '#25b6c4' ? '#fff' : '#111';
        d.style.background = bg;
        d.style.color = c;
        d.style.touchAction = 'manipulation';
        d.addEventListener('click', tileClick);
        zone.appendChild(d);
        updateSubmitState();
      }

      /* =====================================================
         LOCK-IN + CORRECTIONS
         ===================================================== */
      const submitBtn = document.getElementById('submitAnswers');
      submitBtn.addEventListener('click', () => {
        if (submitBtn.disabled) return;

        // remove Lock-In so it cannot be pressed again
        submitBtn.style.display = 'none';
        isLocked = true;

        try { setClearButtonsVisible(false); } catch (e) {}
        try { document.querySelectorAll('.player-select').forEach(s => s.disabled = true);} catch (e) {}

        // Stats scoring
        const placed = [...document.querySelectorAll('.drop-zone .stat')];
        let statsCorrect = 0;
        const total = statBank.length;
        placed.forEach(tile => {
          const owner = tile.parentElement.dataset.owner;
          const key = tile.dataset.key;
          const value = tile.textContent.trim();
          const ownerData = chosenPlayers.find(p => p.name === owner);
          const isCorrect = ownerData && ownerData.stats[key] === value;
          if (isCorrect) {
            tile.classList.add('correct');
            statsCorrect++;
          } else {
            tile.classList.add('wrong');
          }
        });

        // Name scoring
        const selects = document.querySelectorAll('.player-select');
        let nameScore = 0;
        selects.forEach(sel => {
          const card = sel.closest('.player-card');
          if (!card) return;
          if (sel.value && sel.value === card.dataset.player) nameScore++;
        });

        selects.forEach(sel => {
          const card = sel.closest('.player-card');
          if (!card) return;
          const correct = card.dataset.player;
          if (!sel.value) return;
          if (sel.value === correct) sel.classList.add('correct');
          else sel.classList.add('wrong');
          try { setClearButtonsVisible(false); } catch (e) {}
        });

        const multiplier = getDifficultyMultiplier();
        lockedNameScore = nameScore;
        const combinedCount = statsCorrect + nameScore;
        const combinedPoints = combinedCount * multiplier;
        const playersCount = document.querySelectorAll('.player-card').length;
        const maxCount = statBank.length + playersCount;
        const maxCombined = maxCount * multiplier;

        lockedCombinedPoints = combinedPoints;
        lockedMaxCombined = maxCombined;
        lockedCombinedCount = combinedCount;
        lockedStatsScore = statsCorrect;

        scoreOut.innerHTML = `Score: <b>${combinedPoints}/${maxCombined}</b> <small>(Correct: ${combinedCount}/${maxCount} Ã—${multiplier} â€” Stats: ${statsCorrect}/${total}, Names: ${nameScore}/${playersCount})</small>`;

        const wrongOrUnplaced = document.querySelectorAll('.stat.wrong').length +
          Array.from(document.querySelectorAll('.stat')).filter(tile => tile.parentElement.id === 'stats-pool').length;

        const existingBtn = document.getElementById('runCorrectionsBtn');
        if (existingBtn) existingBtn.remove();

        if (wrongOrUnplaced > 0) {
          scoreOut.innerHTML = `Score: <b>${combinedPoints}/${maxCombined}</b> â€“ corrections available <small>(Stats: ${statsCorrect}/${total}, Names: ${nameScore}/${playersCount})</small>`;
          const runBtn = document.createElement('button');
          runBtn.id = 'runCorrectionsBtn';
          runBtn.className = 'btn btn-submit';
          runBtn.textContent = 'Reveal Answers';
          const resetBtn = document.getElementById('resetGame');
          if (resetBtn && resetBtn.parentNode) resetBtn.parentNode.insertBefore(runBtn, resetBtn.nextSibling);
          runBtn.addEventListener('click', () => {
            runBtn.disabled = true;
            runBtn.style.display = 'none';
            performCorrections();
          });
        } else {
          setTimeout(performCorrections, 300);
        }
      });

      function performCorrections() {
        const wrong = [...document.querySelectorAll('.stat.wrong')];
        const unplaced = Array.from(document.querySelectorAll('.stat')).filter(tile => tile.parentElement.id === 'stats-pool');

        wrong.forEach(tile => {
          const p = tile.dataset.player;
          const zone = document.querySelector(`.drop-zone[data-owner="${p}"]`);
          tile.style.transition = 'transform .35s';
          tile.style.transform = 'scale(1.20)';
          setTimeout(() => {
            zone.appendChild(tile);
            tile.classList.remove('wrong');
            tile.classList.add('correct');
            tile.style.transform = 'scale(1)';
          }, 300);
        });

        unplaced.forEach(tile => {
          const p = tile.dataset.player;
          const zone = document.querySelector(`.drop-zone[data-owner="${p}"]`);
          tile.style.transition = 'transform .35s';
          tile.style.transform = 'scale(1.20)';
          setTimeout(() => {
            zone.appendChild(tile);
            tile.classList.add('correct');
            tile.style.transform = 'scale(1)';
          }, 300);
        });

        document.querySelectorAll('.player-card').forEach(card => {
          const sel = card.querySelector('.player-select');
          if (!sel) return;
          const userPick = sel.value;
          const correct = card.dataset.player;
          if (userPick && userPick !== correct) {
            const badge = document.createElement('span');
            badge.className = 'user-guess';
            badge.textContent = userPick;
            sel.after(badge);
            sel.classList.add('wrong');
            setTimeout(() => {
              try {
                sel.innerHTML = `<option value="">Select player</option><option value="${correct}">${correct}</option>`;
              } catch (e) {
                while (sel.firstChild) sel.removeChild(sel.firstChild);
                const o = document.createElement('option'); o.value = ''; o.textContent = 'Select player'; sel.appendChild(o);
                const o2 = document.createElement('option'); o2.value = correct; o2.textContent = correct; sel.appendChild(o2);
              }
              sel.value = correct;
              sel.classList.remove('wrong');
              sel.classList.add('correct');
              sel.disabled = true;
              badge.classList.add('faded');
              setTimeout(() => badge.remove(), 600);
            }, 900);
          } else {
            try {
              sel.innerHTML = `<option value="">Select player</option><option value="${correct}">${correct}</option>`;
            } catch (e) {
              while (sel.firstChild) sel.removeChild(sel.firstChild);
              const o = document.createElement('option'); o.value = ''; o.textContent = 'Select player'; sel.appendChild(o);
              const o2 = document.createElement('option'); o2.value = correct; o2.textContent = correct; sel.appendChild(o2);
            }
            sel.value = correct;
            sel.classList.add('correct');
            sel.disabled = true;
          }
        });

        setTimeout(() => {
          const finalPoints = lockedCombinedPoints;
          const maxCombined = lockedMaxCombined;
          const finalCount = lockedCombinedCount;
          const playersCount = document.querySelectorAll('.player-card').length;
          const statCount = statBank.length;
          scoreOut.innerHTML = `Final Score: <b>${finalPoints}/${maxCombined}</b> <small>(Correct: ${finalCount}/${statCount + playersCount} â€” Stats: ${lockedStatsScore}/${statCount}, Names: ${lockedNameScore}/${playersCount})</small>`;
        }, 420);
      }

      /* =====================================================
         RESET
         ===================================================== */
      document.getElementById("resetGame").addEventListener("click", () => {
        const submitBtnEl = document.getElementById('submitAnswers');
        if (submitBtnEl) submitBtnEl.style.display = '';
        const lingering = document.getElementById('runCorrectionsBtn');
        if (lingering) lingering.remove();
        isLocked = false;
        lockedCombinedPoints = 0;
        lockedMaxCombined = 0;
        lockedCombinedCount = 0;
        lockedStatsScore = 0;
        lockedNameScore = 0;
        setupGame();
      });

      /* =====================================================
         FULLSCREEN FIT
         ===================================================== */
      const fsBtn = document.getElementById("fullscreenBtn");
      const exitFsBtn = document.getElementById("exitFullscreenBtn");
      const main = document.querySelector("main");
      function scaleWrap() { return document.querySelector('main .scale-wrap'); }

      let lockedScale = null; // Store the locked scale value in fullscreen
      let storedNaturalWidth = 0;
      let storedNaturalHeight = 0;
      

      function fitScale() {
        const wrap = scaleWrap();
        if (!wrap) return;
        // If another routine has locked fullscreen scale, do nothing
        try { if (wrap.dataset && wrap.dataset.scaleLocked) return; } catch (e) {}

        // In fullscreen, scale is calculated once and locked - never recalculates
        if (document.fullscreenElement === main || document.webkitFullscreenElement === main) {
          // If scale is already calculated and locked, never recalculate
          if (lockedScale !== null) {
            return; // Keep the locked scale - no resizing in fullscreen
          }
          
          // If we have stored natural dimensions, use them (no need to remeasure)
          if (storedNaturalWidth > 0 && storedNaturalHeight > 0) {
            const currentWidth = window.innerWidth;
            const currentHeight = window.innerHeight;
            const padding = 24;
            const border = 12;
            const availableW = currentWidth - padding - border;
            const availableH = currentHeight - padding - border;
            const scaleX = availableW / storedNaturalWidth;
            const scaleY = availableH / storedNaturalHeight;
            const scale = Math.min(scaleX, scaleY, 1) * 0.92;
            lockedScale = scale;
            wrap.style.transform = `scale(${scale})`;
            return;
          }
          
          // First time: measure natural size (only happens once on fullscreen entry)
          const currentWidth = window.innerWidth;
          const currentHeight = window.innerHeight;
          
          // Temporarily remove transform to measure, but do it in a way that minimizes visual impact
          const hadTransform = wrap.style.transform;
          wrap.style.transform = '';
          
          // Use requestAnimationFrame to measure after layout
          requestAnimationFrame(() => {
            // Get natural dimensions
            const naturalW = wrap.scrollWidth;
            const naturalH = wrap.scrollHeight;
            
            // Store for future use (though we won't need it since scale is locked)
            storedNaturalWidth = naturalW;
            storedNaturalHeight = naturalH;
            
            // Calculate scale
            const padding = 24;
            const border = 12;
            const availableW = currentWidth - padding - border;
            const availableH = currentHeight - padding - border;
            const scaleX = availableW / naturalW;
            const scaleY = availableH / naturalH;
            const scale = Math.min(scaleX, scaleY, 1) * 0.92;
            
            // Lock the scale immediately
            lockedScale = scale;
              wrap.style.transform = `scale(${scale})`;
          });
          return;
        }
        
        // Non-fullscreen scaling (original behavior)
        lockedScale = null; // Clear locked scale when not in fullscreen
        const currentWidth = window.innerWidth;
        const currentHeight = window.innerHeight;
        const naturalW = wrap.scrollWidth;
        const naturalH = wrap.scrollHeight;
        const reservedVertical = 48 + 40 + 24;
        const reservedHorizontal = 120;
        const scaleX = (currentWidth - reservedHorizontal) / naturalW;
        const scaleY = (currentHeight - reservedVertical) / naturalH;
        const EPS = 0.99;
        const scale = Math.min(scaleX, scaleY, 1) * EPS;
        wrap.style.transform = `scale(${scale})`;
      }

      // Lock the current computed transform on `.scale-wrap` and disable
      // card hover-scaling for a short time during placement so nothing
      // reflows or rescales visually.
      function lockWrapDuringPlacement(ms = 600) {
        const wrap = scaleWrap();
        if (!wrap) return;
        // If fullscreen has a pinned scale, don't interfere
        try { if (wrap.dataset && wrap.dataset.scaleLocked) return; } catch (e) {}
        try {
          // Clear any existing timer
          if (wrap._placementTimer) clearTimeout(wrap._placementTimer);

          // Save original inline transform so we can restore later
          wrap.dataset._origTransform = wrap.style.transform || '';

          // Freeze to the computed transform (so changes elsewhere don't nudge it)
          const computed = window.getComputedStyle(wrap).transform;
          if (computed && computed !== 'none') wrap.style.transform = computed;

          // Add body class to disable card scaling
          document.body.classList.add('no-scale');

          // Schedule unlock
          wrap._placementTimer = setTimeout(() => {
            try { document.body.classList.remove('no-scale'); } catch (e) {}
            try {
              wrap.style.transform = wrap.dataset._origTransform || '';
            } catch (e) {}
            try { delete wrap.dataset._origTransform; } catch (e) {}
            wrap._placementTimer = null;
          }, ms);
        } catch (e) {}
      }

      fsBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
          if (main.requestFullscreen) main.requestFullscreen();
          else if (main.webkitRequestFullscreen) main.webkitRequestFullscreen();
          fsBtn.textContent = "â›¶ Exit Fullscreen";
          fsBtn.style.background = "#444";
        } else {
          if (document.exitFullscreen) document.exitFullscreen();
          else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
          fsBtn.textContent = "â›¶ Fullscreen";
          fsBtn.style.background = "#222";
        }
      });

      if (exitFsBtn) {
        exitFsBtn.addEventListener('click', () => {
          if (document.exitFullscreen) document.exitFullscreen();
          else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
          // Mirror the visible state of the main fullscreen button
          if (fsBtn) { fsBtn.textContent = "â›¶ Fullscreen"; fsBtn.style.background = "#222"; }
        });
      }

      function onFsChange() {
        if (document.fullscreenElement === main || document.webkitFullscreenElement === main) {
          lockedScale = null; // Reset locked scale to allow calculation on entry
          storedNaturalWidth = 0;
          storedNaturalHeight = 0;
          // Wait a bit to ensure content is stable, then calculate once
          setTimeout(() => {
            fitScale(); // Calculate once on fullscreen entry
            main.classList.add('fs-fit');
          }, 200);
          // fullscreen: fitScale runs and we rely on CSS banner
        } else {
          lockedScale = null; // Clear locked scale
          storedNaturalWidth = 0;
          storedNaturalHeight = 0;
          const wrap = scaleWrap();
          if (wrap) {
            wrap.style.transform = '';
          }
          main.classList.remove('fs-fit');
          fsBtn.textContent = "â›¶ Fullscreen";
          fsBtn.style.background = "#222";
        }
      }
      document.addEventListener('fullscreenchange', onFsChange);
      document.addEventListener('webkitfullscreenchange', onFsChange);

      /* Debug helper: watches `.scale-wrap` for attribute/child changes and
         polls its measured size/transform. When enabled it logs changes to
         the console so you can reproduce and paste the output for diagnosis. */
      (function(){
        const ENABLE = true; // set to false to disable
        if (!ENABLE) return;
        const wrap = scaleWrap();
        if (!wrap) return;
        let lastW = wrap.offsetWidth;
        let lastH = wrap.offsetHeight;
        let lastTransform = window.getComputedStyle(wrap).transform;

        function log(reason, data) {
          try {
            console.log('[SCALE-WATCH]', new Date().toISOString(), reason, data || {}, {
              offsetWidth: wrap.offsetWidth,
              offsetHeight: wrap.offsetHeight,
              scrollWidth: wrap.scrollWidth,
              scrollHeight: wrap.scrollHeight,
              inlineTransform: wrap.style.transform,
              computedTransform: window.getComputedStyle(wrap).transform,
              dataset: { ...wrap.dataset }
            });
            console.trace();
          } catch (e) {}
        }

        const mo = new MutationObserver(records => {
          for (const r of records) log('mutation', { type: r.type, attributeName: r.attributeName, addedNodes: r.addedNodes.length, removedNodes: r.removedNodes.length });
        });
        mo.observe(wrap, { attributes: true, attributeFilter: ['style','class'], childList: true, subtree: true });

        const poll = setInterval(() => {
          try {
            const w = wrap.offsetWidth, h = wrap.offsetHeight;
            const tf = window.getComputedStyle(wrap).transform;
            if (w !== lastW || h !== lastH || tf !== lastTransform) {
              log('size-change', { prev: { w: lastW, h: lastH, tf: lastTransform }, now: { w, h, tf } });
              lastW = w; lastH = h; lastTransform = tf;
            }
          } catch (e) {}
        }, 250);

        window.__scaleWatcher = {
          stop() { mo.disconnect(); clearInterval(poll); console.log('scaleWatcher stopped'); }
        };
        console.log('Scale watcher active: call window.__scaleWatcher.stop() to disable');
      })();

      /* =====================================================
         TOOLTIP BEHAVIOR (difficulty & submit-disabled)
         ===================================================== */
      (function(){
        const btn = document.getElementById('diffInfoBtn');
        const tip = document.getElementById('diffTooltip');
        const statsPool = document.getElementById('stats-pool');
        if (!btn || !tip) return;

        function show() { 
          tip.style.display = 'block'; 
          tip.setAttribute('aria-hidden','false'); 
          btn.setAttribute('aria-expanded','true');
          
          // Position tooltip - above stats pool on mobile, near button on desktop
          const isMobile = window.innerWidth <= 768;
          
          if (isMobile && statsPool) {
            // Mobile: position above stats pool
            requestAnimationFrame(() => {
              const statsRect = statsPool.getBoundingClientRect();
              const tipRect = tip.getBoundingClientRect();
              const centerX = statsRect.left + (statsRect.width / 2);
              const leftPos = centerX - (tipRect.width / 2);
              // Ensure tooltip doesn't go off screen
              const finalLeft = Math.max(10, Math.min(leftPos, window.innerWidth - tipRect.width - 10));
              tip.style.left = finalLeft + 'px';
              tip.style.right = 'auto';
              tip.style.bottom = (window.innerHeight - statsRect.top + 10) + 'px';
              tip.style.top = 'auto';
              tip.style.transform = 'none';
            });
          } else {
            // Desktop: position near the button
            requestAnimationFrame(() => {
              const btnRect = btn.getBoundingClientRect();
              const tipRect = tip.getBoundingClientRect();
              // Position to the left of button, centered vertically
              tip.style.left = (btnRect.left - tipRect.width - 10) + 'px';
              tip.style.right = 'auto';
              tip.style.top = (btnRect.top + btnRect.height / 2 - tipRect.height / 2) + 'px';
              tip.style.bottom = 'auto';
              tip.style.transform = 'none';
              
              // If tooltip would go off left edge, position to the right instead
              if (parseInt(tip.style.left) < 10) {
                tip.style.left = (btnRect.right + 10) + 'px';
                tip.style.right = 'auto';
              }
            });
          }
        }
        function hide() { tip.style.display = 'none'; tip.setAttribute('aria-hidden','true'); btn.setAttribute('aria-expanded','false'); }

        btn.addEventListener('click', (e)=>{ e.stopPropagation(); if (tip.style.display === 'none' || tip.style.display === '') show(); else hide(); });
        btn.addEventListener('mouseenter', show);
        btn.addEventListener('mouseleave', hide);
        btn.addEventListener('focus', show);
        btn.addEventListener('blur', hide);

        document.addEventListener('keydown', (ev)=>{ if (ev.key === 'Escape') hide(); });
        document.addEventListener('click', (ev)=>{ if (!ev.target.closest || (!btn.contains(ev.target) && !tip.contains(ev.target))) hide(); });
      })();

      (function(){
        const submitBtnEl = document.getElementById('submitAnswers');
        const tipEl = document.getElementById('submitDisabledTip');
        if (!submitBtnEl || !tipEl) return;

        function showTip() {
          if (!submitBtnEl.disabled) return;
          tipEl.style.display = 'block';
          tipEl.setAttribute('aria-hidden', 'false');
        }
        function hideTip() {
          tipEl.style.display = 'none';
          tipEl.setAttribute('aria-hidden', 'true');
        }

        submitBtnEl.addEventListener('mouseenter', showTip);
        submitBtnEl.addEventListener('focus', showTip);
        submitBtnEl.addEventListener('mouseleave', hideTip);
        submitBtnEl.addEventListener('blur', hideTip);

        let lastTouch = 0;
        submitBtnEl.addEventListener('touchstart', (ev) => {
          if (!submitBtnEl.disabled) return;
          const now = Date.now();
          if (now - lastTouch < 700) return;
          showTip();
          lastTouch = now;
        }, { passive: true });
      })();

      /* =====================================================
         SUBMIT ENABLING/REASON
         ===================================================== */
      function updateSubmitState() {
        const submitBtn = document.getElementById('submitAnswers');
        if (!submitBtn) return;
        const tipEl = document.getElementById('submitDisabledTip');

        const totalNeeded = (Array.isArray(statBank) ? statBank.length : 0);
        const placedCount = document.querySelectorAll('.drop-zone .stat').length;
        const selects = Array.from(document.querySelectorAll('.player-select'));
        const allNamesSelected = selects.length > 0 ? selects.every(s => (s.value || '').toString().trim() !== '') : false;
        const ready = totalNeeded > 0 && placedCount >= totalNeeded && allNamesSelected;

        submitBtn.disabled = !ready;
        submitBtn.setAttribute('aria-disabled', (!ready).toString());
        submitBtn.style.opacity = ready ? '' : '0.6';
        submitBtn.title = ready ? '' : 'Place all stats and select names before locking in';

        if (tipEl) {
          if (ready) {
            tipEl.textContent = '';
            tipEl.style.display = 'none';
            tipEl.setAttribute('aria-hidden', 'true');
          } else {
            const reason = getSubmitDisabledReason();
            tipEl.textContent = reason;
            tipEl.style.display = 'block';
            tipEl.setAttribute('aria-hidden', 'false');
          }
        }
      }

      function getSubmitDisabledReason() {
        const totalNeeded = (Array.isArray(statBank) ? statBank.length : 0);
        const placedCount = document.querySelectorAll('.drop-zone .stat').length;
        const missingStats = Math.max(0, totalNeeded - placedCount);
        const selects = Array.from(document.querySelectorAll('.player-select'));
        const missingNames = selects.filter(s => !(s.value || '').toString().trim()).length;
        const parts = [];
        if (missingStats > 0) parts.push(`${missingStats} stat${missingStats>1?'s':''} not placed`);
        if (missingNames > 0) parts.push(`${missingNames} name${missingNames>1?'s':''} not selected`);
        if (parts.length === 0) return 'Locked';
        return parts.join(' and ');
      }

      /* =====================================================
         START
         ===================================================== */
      loadPlayerData();
    </script>
  <script src="../includes/include-html.js"></script>
</body>
</html>






