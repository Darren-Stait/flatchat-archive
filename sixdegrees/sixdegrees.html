<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Flatchat Six Degrees of Seperation</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

<style>
:root {
  --brand: #25b6c4;
  --brand-dark: #1e9aa6;
  --bg: #f4fbfc;
  --text: #1f2937;
  --muted: #6b7280;
}

* { box-sizing: border-box; transition: all 0.2s ease; }

body {
  margin: 0;
  font-family: 'Inter', sans-serif;
  background: var(--bg);
  color: var(--text);
}

.card {
  position: relative;
  max-width: 1000px;
  margin: 50px auto;
  padding: 60px 40px 40px 40px;  /* ‚Üê increase top padding */
  border-radius: 20px;
  background: #ffffff;
  border: 2px solid var(--brand);
  box-shadow: 0 15px 40px rgba(0,0,0,0.08);
}

.goal-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 40px;
}

.player-card { text-align: center; }

.player-headshot {
  width: 120px;
  height: 120px;
  border-radius: 16px;
  object-fit: cover;
  border: 3px solid var(--brand);
  margin-bottom: 12px;
}

.current-headshot {
  width: 90px;
  height: 90px;
  border-radius: 16px;
  object-fit: cover;
  border: 3px solid var(--brand);
  margin: 10px auto 6px;
  display: block;
}

.target-glow {
  box-shadow: 0 0 0 4px rgba(37,182,196,0.2);
}

.player-card strong { color: var(--brand); }

.top-centre {
  text-align: center;
  min-width: 180px;
}

.top-centre .label {
  font-size: 0.85rem;
  color: var(--muted);
}

.current-name {
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--brand);
  margin-top: 4px;
}

.moves {
  margin-top: 12px;
  font-weight: 600;
  color: var(--brand);
}

.choices-grid {
  display: grid;
  gap: 10px;
  grid-template-columns: repeat(10, 1fr);
}

.choice-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  padding: 10px;
  gap: 6px;
}

.club-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  gap: 6px;
  width: 100%;
}

.club-years {
  font-size: 0.85rem;
  font-weight: 600;
  line-height: 1.2;
  min-height: 2.4em;
  max-height: 2.4em;
  overflow: hidden;
}

/* Player / Manager icons */
.choice-card img.entity-img {
  width: 60px;
  height: 60px;
  object-fit: cover;
  border-radius: 14px;
  border: 2px solid var(--brand);
}

/* Club badges */
.club-badge {
  max-width: 100%;
  max-height: 100%;
  width: auto;
  height: auto;
  object-fit: contain;
  border: none;
  border-radius: 0;
}

.choice-card:hover img {
  transform: scale(1.05);
}

.choice-card div {
  font-size: 0.85rem;
  font-weight: 600;
  line-height: 1.2;
}

.path {
  display: flex;
  flex-wrap: wrap;
  gap: 14px;
  margin-top: 50px;
  justify-content: center;
}

.step {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 14px;
  border-radius: 999px;
  background: rgba(37,182,196,0.08);
  border: 1px solid var(--brand);
  font-size: 0.9rem;
}

.step img {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  object-fit: cover;
  border: 1px solid var(--brand);
}

button.primary {
  background: var(--brand);
  color: white;
  border: none;
  padding: 10px 18px;
  border-radius: 10px;
  font-weight: 700;
  cursor: pointer;
}

button.primary:hover {
  background: var(--brand-dark);
}

.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  display: flex;
  justify-content: center;
  align-items: center;
}

.hidden {
  display: none !important;
}

.modal-content {
  background: white;
  padding: 40px;
  border-radius: 16px;
  text-align: center;
  max-width: 400px;
  border: 2px solid var(--brand);
}
.separator {
  grid-column: 1 / -1;
  text-align: center;
  margin: 10px 0;
  font-weight: 600;
  color: var(--muted);
  letter-spacing: 1px;
}
.section-header {
  grid-column: 1 / -1;
  text-align: center;
  margin: 15px 0 5px;
  font-weight: 700;
  font-size: 0.9rem;
  color: var(--muted);
  letter-spacing: 1px;
  text-transform: uppercase;
}
#how-to-play {
  background: rgba(37,182,196,0.08);
  padding: 16px 20px;
  border-radius: 12px;
  margin-bottom: 24px;
  border-left: 4px solid var(--brand);
  position: relative;
  transition: all 0.3s ease;
}

#how-to-play.collapsed {
  max-height: 40px;
  overflow: hidden;
}
.howto-toggle {
  position: absolute;
  top: 12px;
  right: 12px;
  background: transparent;
  border: none;
  font-size: 1.4rem;
  cursor: pointer;
  color: var(--brand);
  transition: transform 0.2s ease;
}
.howto-toggle:active {
  transform: scale(0.9);
}
/* FULLSCREEN MODE */
body.fullscreen .card {
  margin: 0;
  max-width: none;
  width: 100vw;
  height: 100vh;
  border-radius: 0;
  box-shadow: none;
}

body.fullscreen header,
body.fullscreen footer {
  display: none;
}

body.fullscreen {
  overflow: hidden;
}
#navigation-bar {
  display: flex;
  justify-content: center;
  margin-bottom: 15px;
}
.back-btn {
  background: white;
  border: 2px solid var(--brand);
  color: var(--brand);
  padding: 6px 14px;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.back-btn:hover {
  background: var(--brand);
  color: white;
}

.badge-wrapper {
  width: 90px;
  height: 90px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 auto;
  background: white;
  border-radius: 18px;       /* soft rounded square */
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}

@media (max-width: 480px) {
  .club-badge {
    max-width: 55px;
    max-height: 55px;
  }
}

.mode-screen {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.mode-box {
  background: white;
  padding: 40px;
  border-radius: 16px;
  border: 2px solid var(--brand);
  text-align: center;
  width: 350px;
}

.mode-btn {
  width: 100%;
  margin: 10px 0;
}

.custom-setup {
  margin-top: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.custom-setup select {
  padding: 8px;
  border: 2px solid var(--brand);
  border-radius: 8px;
}
.menu-btn {
  position: absolute;
  top: 16px;
  left: 16px;
  background: white;
  color: var(--brand);
  border: 2px solid var(--brand);
  border-radius: 10px;
  padding: 6px 12px;
  font-size: 0.85rem;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0,0,0,0.08);
  transition: all 0.2s ease;
  z-index: 5;
}

.menu-btn:hover {
  background: var(--brand);
  color: white;
  transform: translateY(-2px);
}
.dead-end-message {
  grid-column: 1 / -1;
  text-align: center;
  padding: 20px;
  font-weight: 600;
  color: var(--brand);
  background: rgba(37,182,196,0.08);
  border-radius: 10px;
}

.large-choice img {
  width: 90px;
  height: 90px;
}

.medium-choice img {
  width: 70px;
  height: 70px;
}

.small-choice img {
  width: 55px;
  height: 55px;
}

.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.top-action-btn {
  background: white;
  border: 2px solid var(--brand);
  color: var(--brand);
  padding: 6px 14px;
  border-radius: 10px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.top-action-btn:hover {
  background: var(--brand);
  color: white;
}

@media (max-width: 768px) {

  .club-badge {
    max-width: 70px;
    max-height: 70px;
  }

  /* Make the whole top area compact */
  .goal-row {
    flex-direction: row !important;
    justify-content: space-between;
    align-items: center;
    gap: 6px;
    margin-bottom: 10px;
  }

  .goal-row img {
    margin-bottom: 2px;
  }

  .top-centre {
    margin-bottom: 4px;
  }

  /* Remove vertical stacking */
  .goal-row > div {
    flex: 1;
    text-align: center;
  }

  /* Shrink all headshots */
  .player-headshot,
  .current-headshot {
    width: 48px !important;
    height: 48px !important;
    border-radius: 10px;
  }

  /* Reduce name size */
  .player-name,
  .current-name {
    font-size: 0.7rem;
    line-height: 1.1;
  }

  /* Hide big labels */
  .label {
    display: none;
  }

  /* Reduce moves size */
  .moves {
    font-size: 0.75rem;
  }

  /* Reduce card padding */
  .card {
    margin: 10px;
    padding: 45px 12px 15px;
  }

  .club-badge {
    max-width: 70px;
    max-height: 70px;
  }
.entity-text {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.entity-name {
  font-weight: 600;
  font-size: 0.95rem;
  line-height: 1.2;
}

.entity-years {
  font-size: 0.8rem;
  color: var(--muted);
  line-height: 1.2;
}

.start-screen {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #f8fcfd;
}

/* Shared game-style card */
.game-card {
  background: white;
  border: 2px solid var(--brand);
  border-radius: 20px;
  padding: 50px 60px;
  box-shadow: 0 20px 50px rgba(0,0,0,0.08);
  width: 380px;
  text-align: center;
}

.game-title {
  font-size: 2.4rem;
  font-weight: 700;
  color: var(--brand);
  margin-bottom: 15px;
}

.start-stat {
  font-size: 0.9rem;
  color: var(--muted);
  margin-bottom: 30px;
}

.start-control {
  margin-bottom: 30px;
  text-align: left;
}

.start-control label {
  display: block;
  font-weight: 600;
  margin-bottom: 8px;
}

/* Styled dropdown */
.select-wrapper {
  position: relative;
}

.select-wrapper select {
  width: 100%;
  padding: 10px 12px;
  font-size: 1rem;
  border: 2px solid var(--brand);
  border-radius: 10px;
  background: white;
  appearance: none;
  cursor: pointer;
  transition: 0.2s ease;
}

.select-wrapper select:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(37,182,196,0.2);
}

.start-buttons {
  display: flex;
  flex-direction: column;
  gap: 14px;
}

.primary-btn {
  padding: 12px;
  font-size: 1rem;
  font-weight: 600;
  background: var(--brand);
  color: white;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  transition: 0.2s ease;
}

.primary-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 20px rgba(0,0,0,0.15);
}

.secondary-btn {
  padding: 12px;
  font-size: 1rem;
  font-weight: 600;
  background: white;
  color: var(--brand);
  border: 2px solid var(--brand);
  border-radius: 12px;
  cursor: pointer;
  transition: 0.2s ease;
}

.secondary-btn:hover {
  background: var(--brand);
  color: white;
}
.menu-card {
  background: #f3f7f8;
  border-radius: 18px;
  padding: 50px 60px;
  text-align: center;
  max-width: 500px;
  margin: 60px auto;
}

.menu-title {
  font-size: 2.5rem;
  color: var(--brand);
  margin-bottom: 10px;
}

.menu-stat {
  font-size: 0.9rem;
  color: #666;
  margin-bottom: 30px;
}

.menu-section {
  margin-bottom: 35px;
  text-align: left;
}

.menu-section label {
  font-weight: 600;
  display: block;
  margin-bottom: 10px;
}

.styled-select {
  width: 100%;
  padding: 12px 14px;
  border-radius: 12px;
  border: 2px solid var(--brand);
  font-size: 1rem;
  background: white;
  cursor: pointer;
  transition: 0.2s ease;
}

.styled-select:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(37,182,196,0.25);
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.primary-btn {
  padding: 14px;
  border-radius: 12px;
  border: none;
  background: var(--brand);
  color: white;
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: 0.2s ease;
}

.primary-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(0,0,0,0.15);
}

.outline-btn {
  padding: 14px;
  border-radius: 12px;
  border: 2px solid var(--brand);
  background: white;
  color: var(--brand);
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: 0.2s ease;
}

.outline-btn:hover {
  background: var(--brand);
  color: white;
}
}

@media (max-width: 480px) {

  .large-choice img { width: 70px; height: 70px; }
  .medium-choice img { width: 55px; height: 55px; }
  .small-choice img { width: 45px; height: 45px; }

  .current-name {
    font-size: 1rem;
  }
}

@media (max-width: 1200px) {
  .choices-grid {
    grid-template-columns: repeat(8, 1fr);
  }
}

@media (max-width: 900px) {
  .choices-grid {
    grid-template-columns: repeat(6, 1fr);
  }
}

@media (max-width: 600px) {
  .choices-grid {
    grid-template-columns: repeat(4, 1fr);
  }

  .choice-card img {
    width: 50px;
    height: 50px;
  }
}

@media (max-width: 420px) {
  .choices-grid {
    grid-template-columns: repeat(3, 1fr);
  }

  .choice-card img {
    width: 45px;
    height: 45px;
  }
}
</style>
</head>

<body>

<div data-include="../includes/header.html"></div>

<div id="start-screen">
  <div class="card">

    <div style="text-align:center; margin-bottom:40px;">
      <h1 style="color:var(--brand); margin:0; font-size:2.5rem;">
        Six Degrees of Seperation
      </h1>
    </div>

    <div style="max-width:400px; margin:0 auto 40px;">

      <label style="font-weight:600; display:block; margin-bottom:10px;">
        Minimum Moves
      </label>

      <select id="min-moves"
              style="
                width:100%;
                padding:12px;
                border-radius:12px;
                border:2px solid var(--brand);
                font-size:1rem;
              ">
        <option value="2">Easy (2+)</option>
        <option value="3">Normal (3+)</option>
        <option value="4" selected>Hard (4+)</option>
        <option value="5">Extreme (5+)</option>
      </select>

    </div>

    <div class="menu-stat">
        <div id="total-players-stat"></div>
        <div id="total-pairs-stat" style="margin-top:6px;"></div>
    </div>


    <div style="max-width:400px; margin:0 auto; display:flex; flex-direction:column; gap:15px;">

      <button class="primary" onclick="beginRandomGame()">
        Random Game
      </button>

      <button class="back-btn" onclick="beginCustomGame()">
        Custom Game
      </button>

    </div>

  </div>
</div>

<div id="mode-screen" class="hidden">
  <div class="card" style="max-width:500px; margin:50px auto;">

    <button class="back-btn" onclick="showScreen('start-screen')">
      Back
    </button>

    <h2 style="text-align:center; color:var(--brand); margin-top:20px;">
      Custom Game
    </h2>

    <div style="margin-top:30px;">
      <label style="font-weight:600;">Start Player</label>
      <select id="custom-start" style="width:100%; padding:10px; border:2px solid var(--brand); border-radius:10px; margin-bottom:20px;"></select>

      <label style="font-weight:600;">Target Player</label>
      <select id="custom-target" style="width:100%; padding:10px; border:2px solid var(--brand); border-radius:10px;"></select>
    </div>

    <div style="text-align:center; margin-top:30px;">
      <button class="primary" onclick="startCustomMode()">
        Start Custom Game
      </button>
    </div>

  </div>
</div>

<div id="game-container" class="hidden">
<div class="card">

<div class="top-bar">
  <button class="top-action-btn" onclick="showScreen('start-screen')">
    Back to Menu
  </button>

<button id="fullscreenBtn" class="top-action-btn" onclick="toggleFullscreen()">
  Fullscreen ‚õ∂
</button>
</div>

  <div id="how-to-play">
    <button id="howto-toggle-btn" onclick="toggleHowToPlay()" class="howto-toggle">‚àí</button>
    <h3 style="margin-top:0;color:var(--brand);">How to Play</h3>
    <p style="margin:8px 0;font-size:0.95rem;">Connect the <strong>Start</strong> player to the <strong>Target</strong> player by finding teammates or managers who they once shared a club with. Select a club from the start player's career, then pick a teammate or manager they worked with/under. Keep moving through teammates/managers until you reach the target player!</p>
  </div>

  <div class="goal-row">
    <div class="player-card">
      <img id="start-img" class="player-headshot">
      <div><strong>Start</strong></div>
      <div id="start-name" style="font-weight: 600;"></div>
    </div>

<div class="top-centre">
  <button id="swap-btn" class="top-action-btn" onclick="swapPlayers()">
  ‚áÑ Swap
  </button>
  <div class="label" id="current-label">Current Player</div>
  <img id="current-img" class="current-headshot">
  <div class="current-name" id="current-player"></div>
  <div class="moves">Moves: <span id="move-count">0</span></div>
</div>

    <div class="player-card">
      <img id="target-img" class="player-headshot target-glow">
      <div><strong>Target</strong></div>
      <div id="target-name" style="font-weight: 600;"></div>
    </div>
  </div>

  <div id="navigation-bar" style="margin-top:20px; text-align: center;"></div>
  <div id="choices" class="choices-grid"></div>
  <div id="path" class="path"></div>

  <div style="text-align:center;margin-top:40px;">
    <button class="primary" onclick="startNewGame()">New Puzzle</button>
  </div>

</div>
</div>

<div id="win-modal" class="modal hidden">
  <div class="modal-content">
    <h2>üéâ Connection Complete!</h2>
    <p id="win-text"></p>
    <button class="primary" onclick="startNewGame(); closeModal();">
      Play Again
    </button>
  </div>
</div>

<div data-include="../includes/footer.html"></div>

<script src="./data.js"></script>
<script src="../includes/include-html.js"></script>

<script>
let startPlayer, currentEntity, currentType, targetPlayer;
let path = [];
let selectionMode = "club";
let selectedContext = null;
let availablePlayers = [];
let validPairs = [];
let distanceCache = {};
let MIN_MOVES = 4;

/* =============================
   UTIL
============================= */
function overlaps(a, b) {
  return Math.max(a[0], b[0]) < Math.min(a[1], b[1]);
}

function isManager(name) {
  return !!managers[name];
}

function beginRandomGame() {

  MIN_MOVES = parseInt(document.getElementById("min-moves").value, 10);

  resetPlayerPool();
  showScreen("game-container");
  startNewGame();
}

function beginCustomGame() {

  MIN_MOVES = parseInt(document.getElementById("min-moves").value, 10);

  populateCustomDropdowns();
  showScreen("mode-screen");
}

function swapPlayers() {

  // Only allow swap if no moves made
  if (path.length > 1) {
    return;
  }

  const temp = startPlayer;
  startPlayer = targetPlayer;
  targetPlayer = temp;

  currentEntity = startPlayer;
  currentType = "player";
  path = [startPlayer];
  selectionMode = "club";
  selectedContext = null;

  render();
}

function populateCustomDropdowns() {

  const startSelect = document.getElementById("custom-start");
  const targetSelect = document.getElementById("custom-target");

  startSelect.innerHTML = "";
  targetSelect.innerHTML = "";

  const validStarts = Object.keys(players).filter(s => {

    const distances = distanceCache[s];
    if (!distances) return false;

    return Object.values(distances).some(d =>
      typeof d === "number" && d >= MIN_MOVES
    );
  });

  validStarts.forEach(name => {
    const option = new Option(name, name);
    startSelect.add(option);
  });

  startSelect.onchange = function () {

    const selectedStart = this.value;
    const distances = distanceCache[selectedStart];

    targetSelect.innerHTML = "";

    Object.entries(distances).forEach(([name, dist]) => {
      if (dist >= MIN_MOVES) {
        targetSelect.add(new Option(name, name));
      }
    });
  };

  // Trigger initial target load
  if (validStarts.length > 0) {
    startSelect.value = validStarts[0];
    startSelect.onchange();
  }
}

function updateStartStats() {

  const minMoves = parseInt(
    document.getElementById("min-moves").value,
    10
  );

  const playersList = Object.keys(players);

  let pairCount = 0;

  for (let i = 0; i < playersList.length; i++) {
    for (let j = i + 1; j < playersList.length; j++) {

      const s = playersList[i];
      const t = playersList[j];

      const dist = distanceCache[s]?.[t];

      if (typeof dist === "number" && dist >= minMoves) {
        pairCount++;
      }
    }
  }

  document.getElementById("total-players-stat").textContent =
    `${playersList.length} players loaded`;

  document.getElementById("total-pairs-stat").textContent =
    `${pairCount.toLocaleString()} valid ${minMoves}+ move pairs`;
}

function showScreen(screenId) {

  ["start-screen", "mode-screen", "game-container"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add("hidden");
  });

  const target = document.getElementById(screenId);
  if (target) target.classList.remove("hidden");
}

function backToMenu() {
  showScreen("start-screen");
}

function resetPlayerPool() {

  availablePlayers = Object.keys(players)
    .filter(p => hasValidConnections(p));

  distanceCache = {};

  for (const start of availablePlayers) {

    const distances = computeAllShortestPaths(start);
    distanceCache[start] = distances;
  }
}

function computeAllShortestPaths(startName) {

  const start = { name: startName, type: "player" };
  const queue = [[start, 0]];
  const visited = new Set([startName + "_player"]);

  const result = {};

  while (queue.length) {

    const [node, depth] = queue.shift();
    const key = node.name + "_" + node.type;

    if (node.type === "player" && node.name !== startName) {
      result[node.name] = depth;
    }

    for (const n of getNeighbors(node)) {

      const nKey = n.name + "_" + n.type;

      if (!visited.has(nKey)) {
        visited.add(nKey);
        queue.push([n, depth + 1]);
      }
    }
  }

  return result;
}

/* =============================
   CLUB CONTEXTS (PLAYER OR MANAGER)
============================= */
function getClubContexts(entity) {

  const contexts = [];

  if (currentType === "player") {

    for (const club in players[entity].career) {

      const spells = players[entity].career[club];
      let valid = false;

      spells.forEach(range => {

        const playersList = getPlayersInClubPeriod(club, range)
          .filter(p => p.name !== entity);

        const managersList = getManagersInClubPeriod(club, range);

        if (playersList.length > 0 || managersList.length > 0) {
          valid = true;
        }

      });

      if (valid) contexts.push({ club });
    }

  } else { // manager

    for (const club in managers[entity].career) {

      const spells = managers[entity].career[club];
      let valid = false;

      spells.forEach(range => {

        const playersList = getPlayersInClubPeriod(club, range);

        if (playersList.length > 0) {
          valid = true;
        }

      });

      if (valid) contexts.push({ club });
    }
  }

  return contexts;
}

/* =============================
   PLAYERS IN CLUB PERIOD
============================= */
function getPlayersInClubPeriod(club, range) {
  const res = [];

  for (const p in players) {

    // Skip current entity only if it's a player
    if (currentType === "player" && p === currentEntity) continue;

    if (!players[p].career[club]) continue;

    for (const r of players[p].career[club]) {
      if (overlaps(r, range)) {
        res.push({ name: p, type: "player" });
        break;
      }
    }
  }

  return res;
}

function startRandomMode() {
  document.getElementById("mode-screen").classList.add("hidden");
  startNewGame();
}

function activateCustomMode() {

  document.getElementById("mode-buttons").classList.add("hidden");
  document.getElementById("custom-setup").classList.remove("hidden");

  const startSelect = document.getElementById("custom-start");
  const targetSelect = document.getElementById("custom-target");

  const names = Object.keys(players);

  // Fill start dropdown
  startSelect.innerHTML = "";
  names.forEach(name => {
    const option = document.createElement("option");
    option.value = name;
    option.textContent = name;
    startSelect.appendChild(option);
  });

  // Initially fill target with valid options
  updateTargetOptions();

  // When start changes ‚Üí update target
  startSelect.addEventListener("change", updateTargetOptions);
}

function updateTargetOptions() {

  const start = document.getElementById("custom-start").value;
  const targetSelect = document.getElementById("custom-target");

  targetSelect.innerHTML = "";

  const names = Object.keys(players);

  names.forEach(name => {

    if (name === start) return;

    const length = shortestPathLength(start, name);

    if (length >= MIN_MOVES && length !== Infinity) {
      const option = document.createElement("option");
      option.value = name;
      option.textContent = name;
      targetSelect.appendChild(option);
    }
  });

  // If no valid targets exist
  if (targetSelect.options.length === 0) {
    const option = document.createElement("option");
    option.textContent = "No valid targets available";
    option.disabled = true;
    targetSelect.appendChild(option);
  }
}

function returnToMenu() {

  // Exit fullscreen if active
  if (document.fullscreenElement) {
    document.exitFullscreen();
    document.body.classList.remove("fullscreen");
    document.getElementById("fullscreenBtn").textContent = "Fullscreen";
  }

  // Reset mode screen
  document.getElementById("mode-screen").classList.remove("hidden");

  // Reset custom view
  document.getElementById("custom-setup").classList.add("hidden");
  document.getElementById("mode-buttons").classList.remove("hidden");
}

function startCustomMode() {

  const start = document.getElementById("custom-start").value;
  const target = document.getElementById("custom-target").value;

  if (!start || !target) return;

  startPlayer = start;
  targetPlayer = target;

  currentEntity = start;
  currentType = "player";
  path = [start];
  selectionMode = "club";
  selectedContext = null;

  showScreen("game-container");
  render();
}

function getManagersInClubPeriod(club, range) {
  const res = [];

  for (const m in managers) {

    // Prevent manager self-loop
    if (currentType === "manager" && m === currentEntity) continue;

    if (!managers[m].career[club]) continue;

    for (const r of managers[m].career[club]) {
      if (overlaps(r, range)) {
        res.push({ name: m, type: "manager" });
        break;
      }
    }
  }

  return res;
}

function toggleFullscreen() {
  const btn = document.getElementById("fullscreenBtn");

  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
    document.body.classList.add("fullscreen");
    btn.textContent = "Exit Fullscreen";
  } else {
    document.exitFullscreen();
    document.body.classList.remove("fullscreen");
    btn.textContent = "Fullscreen";
  }
}
function renderChoices(items, mode, append = false) {

  const count = items.length;
  let sizeClass = "large-choice";

  if (count > 16) sizeClass = "small-choice";
  else if (count > 8) sizeClass = "medium-choice";


  const container = document.getElementById("choices");

  if (!append && mode === "club") {
    container.innerHTML = "";
  }

  items.forEach(item => {

    const div = document.createElement("div");
    div.className = `choice-card ${sizeClass}`;

    if (mode === "club") {

      const club = item.club;
      let spells;

      if (currentType === "player") {
        spells = players[currentEntity].career[club];
      } else {
        spells = managers[currentEntity].career[club];
      }

const rangesText = spells
  .map(spell => {
    const s = spell[0];
    const e = spell[1] ?? spell[0];   // ‚Üê fix here
    return s === e ? `${s}` : `${s}‚Äì${e}`;
  })
  .join(", ");

div.innerHTML = `
  <div class="club-item">
    <div class="badge-wrapper">
      <img src="${clubToBadge(club)}" class="club-badge">
    </div>
    <div class="club-years">${rangesText}</div>
  </div>
`;


      div.onclick = () => {
        selectedContext = club;
        selectionMode = "entity";
        render();
      };

    } else if (mode === "entity") {

      if (item.type === "manager") {
div.innerHTML = `
  <img src="${getImage(item.name)}" class="entity-img">
  <div class="entity-text">
    <div class="entity-name">${item.name}</div>
    ${item.overlap ? `<div class="entity-years">(${item.overlap})</div>` : ""}
  </div>
`;

      } else {
div.innerHTML = `
  <img src="${getImage(item.name)}" class="entity-img">
  <div class="entity-text">
    <div class="entity-name">${item.name}</div>
    ${item.overlap ? `<div class="entity-years">(${item.overlap})</div>` : ""}
  </div>
`;


      }

      div.onclick = () => {
        currentEntity = item.name;
        currentType = item.type;
        path.push(item.name);
        selectionMode = "club";
        selectedContext = null;
        render();
        if (path.length - 1 >= MIN_MOVES) {
            checkWin();
        }
      };
    }

    container.appendChild(div);

  });
}

function renderNavigation() {
  const nav = document.getElementById("navigation-bar");
  nav.innerHTML = "";

  if (selectionMode === "entity") {
    const btn = document.createElement("button");
    btn.textContent = "‚Üê Back to Clubs";
    btn.className = "back-btn";
    btn.style.border = "2px solid var(--brand)";
    btn.style.padding = "6px 12px";
    btn.style.fontSize = "0.8rem";

    btn.onclick = () => {
      selectionMode = "club";
      selectedContext = null;
      render();
    };

    nav.appendChild(btn);
  }
}

function toggleHowToPlay() {
  const box = document.getElementById("how-to-play");
  const btn = document.getElementById("howto-toggle-btn");

  box.classList.toggle("collapsed");

  const collapsed = box.classList.contains("collapsed");

  // Save state
  localStorage.setItem("howToPlayCollapsed", collapsed);

  // Update icon
  btn.textContent = collapsed ? "+" : "‚àí";
}

function addSectionHeader(text) {
  const header = document.createElement("div");
  header.className = "section-header";
  header.textContent = text;
  document.getElementById("choices").appendChild(header);
}

function shortestPathLength(startName, targetName) {

  const result = findShortestPath(startName, targetName);

  if (!result) return Infinity;

  return result.length - 1;
}

/* =============================
   MAIN RENDER
============================= */
function render() {
  renderNavigation();
  document.getElementById("start-name").textContent = startPlayer;
  document.getElementById("target-name").textContent = targetPlayer;
  document.getElementById("current-player").textContent = currentEntity;
  document.getElementById("current-label").textContent =
  currentType === "manager"
    ? "Current Manager"
    : "Current Player";
  document.getElementById("current-img").src = getImage(currentEntity, currentType);
  document.getElementById("move-count").textContent = Math.max(0, path.length - 1);

  document.getElementById("start-img").src = getImage(startPlayer);
  document.getElementById("target-img").src = getImage(targetPlayer);

  const swapBtn = document.getElementById("swap-btn");

  if (swapBtn) {
    swapBtn.style.display = path.length > 1 ? "none" : "inline-block";
  }

  document.getElementById("path").innerHTML =
    path.map(p => `
      <div class="step">
        <img src="${isManager(p)?getImage(p):getImage(p)}">
        <span>${p}</span>
      </div>
    `).join("");

  if (selectionMode === "club") {
    renderChoices(getClubContexts(currentEntity), "club");
  }

else if (selectionMode === "entity") {

  const club = selectedContext;
  const container = document.getElementById("choices");
  container.innerHTML = "";

  let playersList = [];
  let managersList = [];

  if (currentType === "player") {

    const playerSpells = players[currentEntity].career[club];

    playerSpells.forEach(pRange => {

      // Players
      for (const p in players) {
        if (p === currentEntity) continue;
        if (!players[p].career[club]) continue;

        players[p].career[club].forEach(oRange => {

          if (overlaps(pRange, oRange)) {

            const overlapStart = Math.max(pRange[0], oRange[0]);
            const overlapEnd = Math.min(pRange[1], oRange[1]);

playersList.push({
  name: p,
  type: "player",
  sortYear: overlapStart,
  overlap: overlapStart === overlapEnd
    ? `${overlapStart}`
    : `${overlapStart}‚Äì${overlapEnd}`
});
          }
        });
      }

      // Managers
      for (const m in managers) {
        if (!managers[m].career[club]) continue;

        managers[m].career[club].forEach(mRange => {

          if (overlaps(pRange, mRange)) {

            const overlapStart = Math.max(pRange[0], mRange[0]);
            const overlapEnd = Math.min(pRange[1], mRange[1]);

managersList.push({
  name: m,
  type: "manager",
  sortYear: overlapStart,
  overlap: overlapStart === overlapEnd
    ? `${overlapStart}`
    : `${overlapStart}‚Äì${overlapEnd}`
});
          }
        });
      }

    });

  } else {

    const managerSpells = managers[currentEntity].career[club];

    managerSpells.forEach(mRange => {

      for (const p in players) {

        if (!players[p].career[club]) continue;

        players[p].career[club].forEach(pRange => {

          if (overlaps(mRange, pRange)) {

            const overlapStart = Math.max(mRange[0], pRange[0]);
            const overlapEnd = Math.min(mRange[1], pRange[1]);

            playersList.push({
              name: p,
              type: "player",
              overlap: overlapStart === overlapEnd
                ? `${overlapStart}`
                : `${overlapStart}‚Äì${overlapEnd}`
            });
          }
        });
      }

    });
  }

  // Remove duplicates
  playersList = removeDuplicateEntities(playersList);
  managersList = removeDuplicateEntities(managersList);
  playersList.sort((a, b) => a.sortYear - b.sortYear);
  managersList.sort((a, b) => a.sortYear - b.sortYear);

  if (playersList.length === 0 && managersList.length === 0) {

    const message = document.createElement("div");
    message.className = "dead-end-message";
    message.textContent = "No more players available this way. Try something else.";
    container.appendChild(message);
    return;
  }

  if (playersList.length > 0) {
    addSectionHeader("Players");
    renderChoices(playersList, "entity");
  }

  if (managersList.length > 0 && currentType === "player") {
    addSectionHeader("Managers");
    renderChoices(managersList, "entity", true);
  }
}
}

function removeDuplicateEntities(list) {

  const merged = new Map();

  list.forEach(item => {

    if (!merged.has(item.name)) {
      merged.set(item.name, {
        ...item,
        overlaps: [item.overlap]
      });
    } else {
      merged.get(item.name).overlaps.push(item.overlap);
    }

  });

  return Array.from(merged.values()).map(item => ({
    ...item,
    overlap: item.overlaps.join(", ")
  }));
}

function showRefreshPoolModal() {

  document.getElementById("win-text").innerHTML = `
    All available player combinations have been used.<br><br>
    Would you like to refresh the player pool?
  `;

  const modal = document.getElementById("win-modal");

  const button = modal.querySelector("button");
  button.textContent = "Refresh Pool";

  button.onclick = () => {
    resetPlayerPool();
    closeModal();
    startNewGame();
  };

  modal.classList.remove("hidden");
}

/* =============================
   GAME START
============================= */
function startNewGame() {

  if (availablePlayers.length < 2) {
    showRefreshPoolModal();
    return;
  }

  let possibleStarts = [];

  for (const s of availablePlayers) {

    const distances = distanceCache[s];
    if (!distances) continue;

    const hasValidTarget = availablePlayers.some(p => {
      if (p === s) return false;
      const d = distances[p];
      return typeof d === "number" && d >= MIN_MOVES;
    });

    if (hasValidTarget) {
      possibleStarts.push(s);
    }
  }

  if (possibleStarts.length === 0) {
    showRefreshPoolModal();
    return;
  }

  const s = possibleStarts[Math.floor(Math.random() * possibleStarts.length)];
  const distances = distanceCache[s];

  const possibleTargets = availablePlayers.filter(p => {
    if (p === s) return false;
    const d = distances[p];
    return typeof d === "number" && d >= MIN_MOVES;
  });

  if (possibleTargets.length === 0) {
    showRefreshPoolModal();
    return;
  }

  const t = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];

  availablePlayers = availablePlayers.filter(p => p !== s && p !== t);

  startPlayer = s;
  targetPlayer = t;

  currentEntity = s;
  currentType = "player";
  path = [s];
  selectionMode = "club";
  selectedContext = null;

  render();
}

function getImage(name, type = null) {

  if (type === "player") return players[name]?.image;
  if (type === "manager") return managers[name]?.image;

  // fallback
  if (players[name]) return players[name].image;
  if (managers[name]) return managers[name].image;

  return "";
}

function clubToBadge(club) {
  return `../../games/badges/${club.toLowerCase().replace(/\s+/g,'')}.png`;
}

function getNeighbors(entity) {

  const neighbors = [];
  const { name, type } = entity;

  if (type === "player") {

    for (const club in players[name].career) {
      const spells = players[name].career[club];

      for (const spell of spells) {

        // Players
        for (const p in players) {
          if (p === name) continue;
          if (!players[p].career[club]) continue;

          for (const otherSpell of players[p].career[club]) {
            if (overlaps(spell, otherSpell)) {
              neighbors.push({ name: p, type: "player" });
              break;
            }
          }
        }

        // Managers
        for (const m in managers) {
          if (!managers[m].career[club]) continue;

          for (const mSpell of managers[m].career[club]) {
            if (overlaps(spell, mSpell)) {
              neighbors.push({ name: m, type: "manager" });
              break;
            }
          }
        }

      }
    }
  }

  else { // manager

    for (const club in managers[name].career) {
      const spells = managers[name].career[club];

      for (const spell of spells) {

        // Players
        for (const p in players) {
          if (!players[p].career[club]) continue;

          for (const pSpell of players[p].career[club]) {
            if (overlaps(spell, pSpell)) {
              neighbors.push({ name: p, type: "player" });
              break;
            }
          }
        }

        // Managers
        for (const m in managers) {
          if (m === name) continue;
          if (!managers[m].career[club]) continue;

          for (const mSpell of managers[m].career[club]) {
            if (overlaps(spell, mSpell)) {
              neighbors.push({ name: m, type: "manager" });
              break;
            }
          }
        }

      }
    }
  }

  return neighbors;
}

function hasValidConnections(playerName) {

  const start = { name: playerName, type: "player" };
  const neighbors = getNeighbors(start);

  return neighbors.some(n => {
    const second = getNeighbors(n);
    return second.length > 0;
  });
}

function findShortestPath(startName, targetName) {

  const start = { name: startName, type: "player" };
  const targetKey = targetName + "_player";

  const queue = [[start]];
  const visited = new Set([start.name + "_player"]);

  while (queue.length) {

    const path = queue.shift();
    const current = path[path.length - 1];
    const key = current.name + "_" + current.type;

    if (key === targetKey) return path;

    const neighbors = getNeighbors(current);

    for (const neighbor of neighbors) {

      const neighborKey = neighbor.name + "_" + neighbor.type;

      if (!visited.has(neighborKey)) {
        visited.add(neighborKey);
        queue.push([...path, neighbor]);
      }
    }
  }

  return null;
}

function checkWin() {

  if (currentEntity === targetPlayer) {

    const moves = path.length - 1;

    if (moves < MIN_MOVES) {
      // Block short wins
      alert("Minimum " + MIN_MOVES + " moves required.");
      return;
    }

    const shortest = findShortestPath(startPlayer, targetPlayer);

    let optimalText = "";

    if (shortest) {
      optimalText = shortest
        .map(n => n.name)
        .join(" ‚Üí ");
    }

    document.getElementById("win-text").innerHTML = `
      You connected them in <strong>${moves}</strong> moves.<br><br>
      <strong>Shortest possible path:</strong><br>
      ${optimalText}
    `;

    document.getElementById("win-modal").classList.remove("hidden");
  }
}

function closeModal() {
  document.getElementById("win-modal").classList.add("hidden");
}

window.addEventListener("load", () => {
  const collapsed = localStorage.getItem("howToPlayCollapsed") === "true";
  const box = document.getElementById("how-to-play");
  const btn = document.getElementById("howto-toggle-btn");

  if (collapsed) {
    box.classList.add("collapsed");
    btn.textContent = "+";
  } else {
    btn.textContent = "‚àí";
  }
});

document.addEventListener("fullscreenchange", () => {
  const btn = document.getElementById("fullscreenBtn");

  if (!document.fullscreenElement) {
    document.body.classList.remove("fullscreen");
    btn.textContent = "Fullscreen";
  }
});

resetPlayerPool();      // builds distanceCache + availablePlayers
updateStartStats();     // now stats can use distanceCache

document.getElementById("min-moves")
  .addEventListener("change", updateStartStats);

</script>
</body>
</html>